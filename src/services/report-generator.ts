import { createChildLogger } from '../lib/logger.js';
import type { Severity, VulnCategory } from '../types/index.js';

const logger = createChildLogger('report-generator');

const SEVERITY_ORDER: Severity[] = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'];
const SEVERITY_EMOJI: Record<Severity, string> = {
  CRITICAL: 'üî¥',
  HIGH: 'üü†',
  MEDIUM: 'üü°',
  LOW: 'üü¢',
  INFO: '‚ÑπÔ∏è',
};

export class ReportGenerator {
  async generate(
    audit: any,
    format: string
  ): Promise<{ content: string; filePath?: string }> {
    logger.info({ auditId: audit.id, format }, 'Generating report');

    switch (format.toLowerCase()) {
      case 'markdown':
      case 'md':
        return { content: this.generateMarkdown(audit) };
      case 'json':
        return { content: this.generateJson(audit) };
      case 'html':
        return { content: this.generateHtml(audit) };
      default:
        return { content: this.generateMarkdown(audit) };
    }
  }

  private generateMarkdown(audit: any): string {
    const project = audit.project;
    const findings = audit.vulnerabilities || [];

    // Group findings by severity
    const bySeverity = this.groupBySeverity(findings);

    let report = `# Security Audit Report

## ${project.name}

**Audit ID:** ${audit.id}  
**Date:** ${new Date(audit.completedAt || audit.createdAt).toLocaleDateString()}  
**Duration:** ${audit.duration ? `${Math.round(audit.duration / 60)} minutes` : 'N/A'}  
**Repository:** ${project.githubUrl}  
**Commit:** ${project.commitHash || 'N/A'}  

---

## Executive Summary

This security audit was conducted on the ${project.name} smart contracts. The audit identified **${findings.length} findings** across the codebase.

### Findings Summary

| Severity | Count |
|----------|-------|
${SEVERITY_ORDER.map(s => `| ${SEVERITY_EMOJI[s]} ${s} | ${bySeverity[s]?.length || 0} |`).join('\n')}

### Risk Assessment

${this.generateRiskAssessment(findings)}

---

## Scope

### Contracts Analyzed

| File | Lines |
|------|-------|
${project.contracts?.map((c: any) => `| ${c.filePath} | ${c.lines} |`).join('\n') || 'N/A'}

**Total Lines of Code:** ${project.totalLines || 'N/A'}

### Protocol Type

${project.protocolType || 'Not specified'}

---

## Detailed Findings

`;

    // Add findings by severity
    for (const severity of SEVERITY_ORDER) {
      const severityFindings = bySeverity[severity] || [];
      if (severityFindings.length === 0) continue;

      report += `### ${SEVERITY_EMOJI[severity]} ${severity} (${severityFindings.length})\n\n`;

      severityFindings.forEach((finding: any, index: number) => {
        report += this.formatFinding(finding, index + 1);
      });
    }

    report += `
---

## Appendix

### Methodology

This audit was conducted using a combination of:
1. **Static Analysis** - Automated tools including Slither and custom pattern matchers
2. **AI-Assisted Review** - Deep semantic analysis using large language models
3. **Pattern Matching** - Comparison against known vulnerability patterns from 20,000+ historical findings

### Severity Classification

| Severity | Description |
|----------|-------------|
| üî¥ CRITICAL | Direct loss of funds or complete protocol failure |
| üü† HIGH | Significant impact on protocol functionality or user funds |
| üü° MEDIUM | Limited impact, requires specific conditions |
| üü¢ LOW | Minor issues, best practice violations |
| ‚ÑπÔ∏è INFO | Informational findings, gas optimizations |

### Disclaimer

This audit is not a guarantee of security. Smart contracts are complex systems and may contain undiscovered vulnerabilities. The findings in this report are based on the code at the time of audit.

---

*Report generated by Smart Contract Auditor*  
*Generated at: ${new Date().toISOString()}*
`;

    return report;
  }

  private formatFinding(finding: any, index: number): string {
    let section = `#### ${index}. ${finding.title}

**Category:** ${finding.category}  
**Status:** ${finding.status}  
**Confidence:** ${Math.round((finding.confidence || 0.5) * 100)}%  

`;

    if (finding.filePath) {
      section += `**Location:** \`${finding.filePath}\``;
      if (finding.startLine) {
        section += ` (Lines ${finding.startLine}-${finding.endLine || finding.startLine})`;
      }
      section += '\n\n';
    }

    section += `**Description:**

${finding.description}

`;

    if (finding.codeSnippet) {
      section += `**Vulnerable Code:**

\`\`\`solidity
${finding.codeSnippet}
\`\`\`

`;
    }

    if (finding.poc) {
      section += `**Proof of Concept:**

${finding.poc.verified ? '‚úÖ Verified' : '‚ö†Ô∏è Not verified'}

\`\`\`solidity
${finding.poc.code?.substring(0, 1000)}${finding.poc.code?.length > 1000 ? '\n// ... truncated' : ''}
\`\`\`

`;
    }

    if (finding.remediation) {
      section += `**Recommendation:**

${finding.remediation}

`;
    }

    if (finding.references?.length > 0) {
      section += `**References:**
${finding.references.map((r: string) => `- ${r}`).join('\n')}

`;
    }

    section += '---\n\n';

    return section;
  }

  private generateRiskAssessment(findings: any[]): string {
    const critical = findings.filter(f => f.severity === 'CRITICAL').length;
    const high = findings.filter(f => f.severity === 'HIGH').length;

    if (critical > 0) {
      return `‚ö†Ô∏è **HIGH RISK** - ${critical} critical vulnerabilities found. Deployment is not recommended until these issues are resolved.`;
    } else if (high > 0) {
      return `‚ö†Ô∏è **MEDIUM-HIGH RISK** - ${high} high-severity issues found. These should be addressed before deployment.`;
    } else if (findings.length > 0) {
      return `‚úÖ **LOW-MEDIUM RISK** - No critical or high-severity issues found. Minor issues should be reviewed.`;
    } else {
      return `‚úÖ **LOW RISK** - No significant vulnerabilities detected. Standard security practices recommended.`;
    }
  }

  private groupBySeverity(findings: any[]): Record<Severity, any[]> {
    const result: Record<Severity, any[]> = {
      CRITICAL: [],
      HIGH: [],
      MEDIUM: [],
      LOW: [],
      INFO: [],
    };

    for (const finding of findings) {
      const severity = finding.severity as Severity;
      if (result[severity]) {
        result[severity].push(finding);
      }
    }

    return result;
  }

  private generateJson(audit: any): string {
    return JSON.stringify({
      audit: {
        id: audit.id,
        status: audit.status,
        createdAt: audit.createdAt,
        completedAt: audit.completedAt,
        duration: audit.duration,
      },
      project: {
        name: audit.project.name,
        githubUrl: audit.project.githubUrl,
        commitHash: audit.project.commitHash,
        protocolType: audit.project.protocolType,
        totalContracts: audit.project.totalContracts,
        totalLines: audit.project.totalLines,
      },
      summary: {
        totalFindings: audit.totalFindings,
        critical: audit.criticalCount,
        high: audit.highCount,
        medium: audit.mediumCount,
        low: audit.lowCount,
        info: audit.infoCount,
      },
      findings: audit.vulnerabilities.map((v: any) => ({
        id: v.id,
        category: v.category,
        severity: v.severity,
        title: v.title,
        description: v.description,
        location: {
          filePath: v.filePath,
          startLine: v.startLine,
          endLine: v.endLine,
        },
        confidence: v.confidence,
        status: v.status,
        remediation: v.remediation,
        poc: v.poc ? {
          verified: v.poc.verified,
          code: v.poc.code,
        } : null,
        references: v.references,
      })),
      generatedAt: new Date().toISOString(),
    }, null, 2);
  }

  private generateHtml(audit: any): string {
    const markdown = this.generateMarkdown(audit);
    
    // Basic HTML wrapper with styling
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audit Report - ${audit.project.name}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      color: #333;
    }
    h1, h2, h3, h4 { color: #1a1a1a; }
    code {
      background: #f4f4f4;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      font-size: 0.9em;
    }
    pre {
      background: #1a1a1a;
      color: #f4f4f4;
      padding: 1rem;
      border-radius: 5px;
      overflow-x: auto;
    }
    pre code {
      background: none;
      padding: 0;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1rem 0;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 0.75rem;
      text-align: left;
    }
    th { background: #f4f4f4; }
    hr { border: none; border-top: 1px solid #eee; margin: 2rem 0; }
    .severity-critical { color: #dc3545; }
    .severity-high { color: #fd7e14; }
    .severity-medium { color: #ffc107; }
    .severity-low { color: #28a745; }
  </style>
</head>
<body>
  <div id="content">
    ${this.markdownToHtml(markdown)}
  </div>
</body>
</html>`;
  }

  private markdownToHtml(markdown: string): string {
    // Basic markdown to HTML conversion
    return markdown
      .replace(/^### (.*$)/gim, '<h3>$1</h3>')
      .replace(/^## (.*$)/gim, '<h2>$1</h2>')
      .replace(/^# (.*$)/gim, '<h1>$1</h1>')
      .replace(/^\*\*(.*)\*\*/gim, '<strong>$1</strong>')
      .replace(/^\*(.*)\*/gim, '<em>$1</em>')
      .replace(/\`\`\`solidity\n([\s\S]*?)\`\`\`/g, '<pre><code class="language-solidity">$1</code></pre>')
      .replace(/\`\`\`\n([\s\S]*?)\`\`\`/g, '<pre><code>$1</code></pre>')
      .replace(/\`([^\`]+)\`/g, '<code>$1</code>')
      .replace(/^\- (.*$)/gim, '<li>$1</li>')
      .replace(/\n\n/g, '</p><p>')
      .replace(/^(.*)$/gim, '<p>$1</p>')
      .replace(/<p><\/p>/g, '')
      .replace(/<p>(<h[1-6]>)/g, '$1')
      .replace(/(<\/h[1-6]>)<\/p>/g, '$1')
      .replace(/<p>(<pre>)/g, '$1')
      .replace(/(<\/pre>)<\/p>/g, '$1')
      .replace(/<p>(<li>)/g, '<ul>$1')
      .replace(/(<\/li>)<\/p>/g, '$1</ul>')
      .replace(/<p>---<\/p>/g, '<hr>');
  }
}
