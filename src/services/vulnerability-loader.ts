/**
 * Vulnerability Loader Service
 * 
 * Dynamically loads vulnerability patterns and checklists from the knowledge base
 * to inject into AI Auditor prompts based on protocol type.
 */

import { promises as fs } from 'fs';
import * as path from 'path';
import { createChildLogger } from '../lib/logger.js';

const logger = createChildLogger('vulnerability-loader');

// Base path for vulnerability knowledge - use process.cwd() relative paths
const getBasePath = () => {
  // Try to find the data directory relative to process.cwd() or use absolute
  const possiblePaths = [
    path.join(process.cwd(), 'data/vulnerabilities'),
    path.join(process.cwd(), 'projects/smart-contract-auditor/data/vulnerabilities'),
    '/Users/billyc/clawd/projects/smart-contract-auditor/data/vulnerabilities'
  ];
  return possiblePaths[0]; // Will try others if file not found
};

const VULN_BASE_PATH = getBasePath();
const PATTERNS_BASE_PATH = VULN_BASE_PATH.replace('/vulnerabilities', '/patterns');

// Cache for loaded files
const fileCache = new Map<string, { content: string; loadedAt: number }>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

export interface LoadedKnowledge {
  protocolPatterns: string;
  crossProtocolRisks: string;
  economicRisks: string;
  checklist: string;
  auditingTechniques: string;
}

export class VulnerabilityLoader {
  
  /**
   * Load all relevant knowledge for a given protocol type
   */
  async loadForProtocol(protocolType: string): Promise<LoadedKnowledge> {
    const normalizedType = protocolType.toUpperCase();
    
    logger.info({ protocolType: normalizedType }, 'Loading vulnerability knowledge for protocol');
    
    const [
      protocolPatterns,
      crossProtocolRisks,
      economicRisks,
      checklist,
      auditingTechniques
    ] = await Promise.all([
      this.loadProtocolSpecificPatterns(normalizedType),
      this.loadCrossProtocolRisks(),
      this.loadEconomicRisks(),
      this.loadChecklist(normalizedType),
      this.loadAuditingTechniques()
    ]);
    
    return {
      protocolPatterns,
      crossProtocolRisks,
      economicRisks,
      checklist,
      auditingTechniques
    };
  }
  
  /**
   * Load protocol-specific vulnerability patterns
   */
  private async loadProtocolSpecificPatterns(protocolType: string): Promise<string> {
    const mappings: Record<string, string[]> = {
      'LENDING': ['lending.md'],
      'BORROW': ['lending.md'],
      'DEX': ['dex-amm.md'],
      'AMM': ['dex-amm.md'],
      'SWAP': ['dex-amm.md'],
      'VAULT': ['staking-lsd.md'],  // closest match
      'YIELD': ['staking-lsd.md'],
      'STAKING': ['staking-lsd.md'],
      'LSD': ['staking-lsd.md'],
      'RESTAKING': ['staking-lsd.md', 'emerging-protocols.md', 'cryptographic-primitives.md'],
      'EIGENLAYER': ['staking-lsd.md', 'emerging-protocols.md', 'cryptographic-primitives.md'],
      'AVS': ['emerging-protocols.md', 'cryptographic-primitives.md'],
      'RELAY': ['emerging-protocols.md', 'cryptographic-primitives.md'],
      'BLS': ['cryptographic-primitives.md'],
      'ZK': ['cryptographic-primitives.md', 'l2-specific.md'],
      'ZKPROOF': ['cryptographic-primitives.md'],
      'INTENT': ['emerging-protocols.md'],
      'COW': ['emerging-protocols.md'],
      'UNISWAPX': ['emerging-protocols.md'],
      'SOLVER': ['emerging-protocols.md'],
      'POINTS': ['emerging-protocols.md'],
      'AIRDROP': ['emerging-protocols.md'],
      'L2': ['l2-specific.md'],
      'LAYER2': ['l2-specific.md'],
      'ARBITRUM': ['l2-specific.md'],
      'OPTIMISM': ['l2-specific.md'],
      'BASE': ['l2-specific.md'],
      'ZKSYNC': ['l2-specific.md'],
      'SCROLL': ['l2-specific.md'],
      'LINEA': ['l2-specific.md'],
      'POLYGON': ['l2-specific.md'],
      'BRIDGE': ['bridge-crosschain.md', 'l2-specific.md', 'external-integration.md'],
      'CROSSCHAIN': ['bridge-crosschain.md', 'external-integration.md'],
      'WORMHOLE': ['bridge-crosschain.md', 'cryptographic-primitives.md'],
      'LAYERZERO': ['bridge-crosschain.md', 'external-integration.md'],
      'CCIP': ['bridge-crosschain.md', 'external-integration.md'],
      'AXELAR': ['bridge-crosschain.md', 'external-integration.md'],
      'RELAYER': ['bridge-crosschain.md'],
      'LOCK_MINT': ['bridge-crosschain.md'],
      'FCFS': ['fcfs-tiering-systems.md', 'staking-lsd.md'],
      'TIER': ['fcfs-tiering-systems.md', 'staking-lsd.md'],
      'TIERED': ['fcfs-tiering-systems.md', 'staking-lsd.md'],
      'REWARD': ['fcfs-tiering-systems.md'],
      'FENWICK': ['fcfs-tiering-systems.md'],
      'RANKING': ['fcfs-tiering-systems.md'],
      'STABLECOIN': ['stablecoin-cdp.md', 'lending.md'],
      'CDP': ['stablecoin-cdp.md', 'lending.md'],
      'STABLE': ['stablecoin-cdp.md'],
      'MIM': ['stablecoin-cdp.md', 'lending.md'],
      'CAULDRON': ['stablecoin-cdp.md'],
      'TROVE': ['stablecoin-cdp.md', 'lending.md'],
      'GOVERNANCE': ['governance-dao.md'],
      'DAO': ['governance-dao.md'],
      'GOVERNOR': ['governance-dao.md'],
      'VOTING': ['governance-dao.md'],
      'TIMELOCK': ['governance-dao.md'],
      'MULTISIG': ['governance-dao.md'],
      'VETOKEN': ['governance-dao.md'],
      'PROXY': ['proxy-upgrade-patterns.md'],
      'UPGRADE': ['proxy-upgrade-patterns.md'],
      'UPGRADEABLE': ['proxy-upgrade-patterns.md'],
      'UUPS': ['proxy-upgrade-patterns.md'],
      'BEACON': ['proxy-upgrade-patterns.md'],
      'DIAMOND': ['proxy-upgrade-patterns.md'],
      'TRANSPARENT_PROXY': ['proxy-upgrade-patterns.md'],
      'TOKEN': ['weird-erc20-tokens.md'],
      'ERC20': ['weird-erc20-tokens.md'],
      'WEIRD_TOKEN': ['weird-erc20-tokens.md'],
      'FEE_ON_TRANSFER': ['weird-erc20-tokens.md'],
      'REBASING': ['weird-erc20-tokens.md'],
      'PERMISSIONLESS': ['weird-erc20-tokens.md', 'dex-amm.md'],
    };
    
    // Find matching files
    const filesToLoad: string[] = [];
    for (const [key, files] of Object.entries(mappings)) {
      if (protocolType.includes(key)) {
        filesToLoad.push(...files);
      }
    }
    
    // Default to all if no specific match
    if (filesToLoad.length === 0) {
      filesToLoad.push('lending.md', 'dex-amm.md', 'staking-lsd.md');
    }
    
    // Remove duplicates
    const uniqueFiles = Array.from(new Set(filesToLoad));
    
    // Load and combine
    const contents = await Promise.all(
      uniqueFiles.map(f => this.loadFile(path.join(VULN_BASE_PATH, 'protocol-specific', f)))
    );
    
    return contents.filter(Boolean).join('\n\n---\n\n');
  }
  
  /**
   * Load cross-protocol risks (oracle, external integration)
   */
  private async loadCrossProtocolRisks(): Promise<string> {
    const files = ['oracle-manipulation.md', 'external-integration.md'];
    
    const contents = await Promise.all(
      files.map(f => this.loadFile(path.join(VULN_BASE_PATH, 'cross-protocol', f)))
    );
    
    return contents.filter(Boolean).join('\n\n---\n\n');
  }
  
  /**
   * Load economic attack vectors (including MEV patterns)
   */
  private async loadEconomicRisks(): Promise<string> {
    // Load economic vulnerability files
    const economicFiles = [
      'liquidation-risks.md',
      'state-transition-risks.md',
      'mev-patterns.md'  // NEW: MEV attack patterns
    ];
    
    const contents = await Promise.all(
      economicFiles.map(f => this.loadFile(path.join(VULN_BASE_PATH, 'economic', f)))
    );
    
    // Also load pattern files
    const patternFiles = [
      'economic-attack-vectors.md',
      'privilege-escalation-patterns.md',
      'cross-contract-attack-patterns.md'
    ];
    
    const patternContents = await Promise.all(
      patternFiles.map(f => this.loadFile(path.join(PATTERNS_BASE_PATH, f)))
    );
    
    return [...contents, ...patternContents].filter(Boolean).join('\n\n---\n\n');
  }
  
  /**
   * Load the appropriate audit checklist
   */
  private async loadChecklist(protocolType: string): Promise<string> {
    const mappings: Record<string, string> = {
      'LENDING': 'lending-audit-checklist.md',
      'BORROW': 'lending-audit-checklist.md',
      'DEX': 'dex-audit-checklist.md',
      'AMM': 'dex-audit-checklist.md',
      'SWAP': 'dex-audit-checklist.md',
      'YIELD': 'yield-audit-checklist.md',
      'VAULT': 'yield-audit-checklist.md',
      'L2': 'l2-emerging-checklist.md',
      'LAYER2': 'l2-emerging-checklist.md',
      'ARBITRUM': 'l2-emerging-checklist.md',
      'OPTIMISM': 'l2-emerging-checklist.md',
      'BASE': 'l2-emerging-checklist.md',
      'ZKSYNC': 'l2-emerging-checklist.md',
      'RESTAKING': 'l2-emerging-checklist.md',
      'EIGENLAYER': 'l2-emerging-checklist.md',
      'INTENT': 'l2-emerging-checklist.md',
      'POINTS': 'l2-emerging-checklist.md',
      'AIRDROP': 'l2-emerging-checklist.md',
    };
    
    // Find matching checklist
    let checklistFile = 'general-audit-checklist.md'; // default
    for (const [key, file] of Object.entries(mappings)) {
      if (protocolType.includes(key)) {
        checklistFile = file;
        break;
      }
    }
    
    // Load primary checklist
    const primaryChecklist = await this.loadFile(path.join(VULN_BASE_PATH, 'checklists', checklistFile));
    
    // For certain protocol types, also load callback/integration checklist
    const needsCallbackChecklist = ['LENDING', 'VAULT', 'YIELD', 'DEX'].some(k => protocolType.includes(k));
    if (needsCallbackChecklist) {
      const callbackChecklist = await this.loadFile(path.join(VULN_BASE_PATH, 'checklists', 'callback-integration-checklist.md'));
      return primaryChecklist + '\n\n---\n\n' + callbackChecklist;
    }
    
    return primaryChecklist;
  }
  
  /**
   * Load advanced auditing techniques (invariants, attack paths)
   */
  private async loadAuditingTechniques(): Promise<string> {
    // Load from pattern files that describe HOW to audit
    const files = [
      'lending-protocol-patterns.md',
      'yield-tokenization-patterns.md',
      'dex-business-logic-patterns.md'
    ];
    
    const contents = await Promise.all(
      files.map(f => this.loadFile(path.join(PATTERNS_BASE_PATH, f)))
    );
    
    return contents.filter(Boolean).join('\n\n---\n\n');
  }
  
  /**
   * Load a file with caching
   */
  private async loadFile(filePath: string): Promise<string> {
    // Check cache
    const cached = fileCache.get(filePath);
    if (cached && Date.now() - cached.loadedAt < CACHE_TTL) {
      return cached.content;
    }
    
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      fileCache.set(filePath, { content, loadedAt: Date.now() });
      logger.debug({ filePath }, 'Loaded vulnerability knowledge file');
      return content;
    } catch (error) {
      logger.warn({ filePath, error }, 'Failed to load vulnerability file');
      return '';
    }
  }
  
  /**
   * Clear the file cache
   */
  clearCache(): void {
    fileCache.clear();
    logger.info('Vulnerability knowledge cache cleared');
  }
  
  /**
   * Get cache stats
   */
  getCacheStats(): { files: number; totalSize: number } {
    let totalSize = 0;
    const entries = Array.from(fileCache.values());
    for (const cached of entries) {
      totalSize += cached.content.length;
    }
    return {
      files: fileCache.size,
      totalSize
    };
  }
}

// Singleton instance
export const vulnerabilityLoader = new VulnerabilityLoader();
