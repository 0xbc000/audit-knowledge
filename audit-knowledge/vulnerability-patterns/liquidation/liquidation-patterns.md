# Liquidation Vulnerability Patterns

## 類別
Liquidation / Lending / Perpetuals

---

## Pattern 1: Self-Liquidation Profit Extraction

### 描述
借款人自行清算自己的倉位，利用清算折扣（liquidation bonus）獲利，繞過正常還款流程。

### 漏洞程式碼
```solidity
function liquidate(address borrower, uint256 repayAmount) external {
    require(isUnhealthy(borrower), "Position healthy");
    
    uint256 collateralSeized = repayAmount * liquidationBonus / PRECISION;
    // ❌ 沒有檢查 msg.sender != borrower
    _repay(borrower, repayAmount);
    _seizeCollateral(borrower, msg.sender, collateralSeized);
}
```

### 攻擊流程
1. 借款人存入 $1000 collateral，借出 $800
2. 價格下跌使倉位 unhealthy
3. 借款人用自有資金清算自己，償還 $400
4. 獲得 $400 × 1.10 = $440 collateral（10% bonus）
5. 淨獲利 $40（來自協議/其他用戶）

### 修復
```solidity
require(msg.sender != borrower, "Cannot self-liquidate");
```

### 真實案例
- Sentiment V2: 允許 self-liquidation，liquidation bonus 成為提款折扣
- RAAC 2025: 缺少 self-liquidation 檢查

### 嚴重性: Medium-High

---

## Pattern 2: Stale Price During Liquidation

### 描述
清算使用過時的 oracle 價格，導致在價格已回升時仍可清算，或在暴跌時清算不足。

### 漏洞程式碼
```solidity
function liquidate(address borrower, uint256 repayAmount) external {
    // ❌ 使用 cached price，可能已過時
    uint256 collateralValue = userCollateral[borrower] * lastPrice / 1e18;
    uint256 debtValue = userDebt[borrower];
    require(collateralValue * 100 < debtValue * liquidationThreshold, "Healthy");
    // ...
}
```

### 正確做法
```solidity
function liquidate(address borrower, uint256 repayAmount) external {
    // ✅ 取得最新價格 + freshness check
    (uint256 price, uint256 updatedAt) = oracle.latestRoundData();
    require(block.timestamp - updatedAt < MAX_STALENESS, "Stale price");
    // ...
}
```

### 嚴重性: High

---

## Pattern 3: Liquidation Threshold vs LTV Confusion

### 描述
混淆 Loan-to-Value（借出上限）和 Liquidation Threshold（清算門檻），導致新借款立即可被清算，或倉位永遠無法被清算。

### 漏洞模式
```solidity
// 配置錯誤：LTV > Liquidation Threshold
// LTV = 80%, Liquidation Threshold = 75%
// 用戶可以借到 80%，但 75% 就觸發清算 → 立即可清算

function borrow(uint256 amount) external {
    require(getDebtRatio(msg.sender) <= LTV, "Exceeds LTV");  // 80%
}

function isLiquidatable(address user) public view returns (bool) {
    return getDebtRatio(user) >= LIQUIDATION_THRESHOLD;  // 75%
}
```

### 不變量
```
LTV < Liquidation Threshold < 100%
```
必須在 setter 中強制執行此不變量。

### 嚴重性: Critical

---

## Pattern 4: Partial Liquidation Dust Attack

### 描述
攻擊者反覆進行極小額清算，每次賺取 liquidation bonus 但留下「dust」（極小倉位），最終使倉位無法被完全清算。

### 漏洞程式碼
```solidity
function liquidate(address borrower, uint256 repayAmount) external {
    require(repayAmount > 0, "Zero amount");
    // ❌ 沒有最小清算量檢查
    // ❌ 沒有檢查剩餘倉位是否有意義
    
    uint256 collateralSeized = repayAmount * liquidationBonus / PRECISION;
    _repay(borrower, repayAmount);
    _seizeCollateral(borrower, msg.sender, collateralSeized);
}
```

### 修復
```solidity
function liquidate(address borrower, uint256 repayAmount) external {
    require(repayAmount >= MIN_LIQUIDATION, "Below minimum");
    
    uint256 remainingDebt = userDebt[borrower] - repayAmount;
    // 清算後剩餘倉位必須 > 最小倉位 或完全清算
    require(
        remainingDebt == 0 || remainingDebt >= MIN_POSITION,
        "Would leave dust"
    );
    // ...
}
```

### 嚴重性: Medium

---

## Pattern 5: Bad Debt Socialization Missing

### 描述
當 collateral < debt（underwater position），清算無法覆蓋全部債務。如果沒有 bad debt 處理機制，壞帳會永久停留在系統中，影響所有存款人。

### 漏洞程式碼
```solidity
function liquidate(address borrower, uint256 repayAmount) external {
    uint256 collateralSeized = repayAmount * liquidationBonus / PRECISION;
    
    // ❌ 如果 collateral 不夠，seize 會 revert
    // 整個 underwater position 變成無法清算
    require(
        userCollateral[borrower] >= collateralSeized,
        "Insufficient collateral"
    );
}
```

### 正確做法
```solidity
function liquidate(address borrower, uint256 repayAmount) external {
    uint256 maxSeizable = userCollateral[borrower];
    uint256 desiredSeize = repayAmount * liquidationBonus / PRECISION;
    uint256 actualSeize = min(desiredSeize, maxSeizable);
    
    _seizeCollateral(borrower, msg.sender, actualSeize);
    _repay(borrower, repayAmount);
    
    // 處理剩餘壞帳
    if (userDebt[borrower] > 0 && userCollateral[borrower] == 0) {
        _socializeBadDebt(borrower);  // 分攤給所有存款人
    }
}
```

### 真實案例
- Wise Lending 2024: 缺少 bad debt socialization
- 多個 lending protocol 有類似問題

### 嚴重性: High-Critical

---

## Pattern 6: Liquidation During Paused State Inconsistency

### 描述
協議暫停時如果同時禁止清算和存款/還款，用戶無法補充 collateral，倉位可能在恢復後立即被清算。

### 漏洞模式
```solidity
modifier whenNotPaused() {
    require(!paused, "Paused");
    _;
}

function deposit() external whenNotPaused { ... }
function repay() external whenNotPaused { ... }
function liquidate() external whenNotPaused { ... }  // ⚠️ 全部暫停
```

### 最佳實踐
```solidity
// 暫停時：禁止借款，但允許還款和存款（用戶自救）
// 清算可以選擇暫停或不暫停，取決於設計
function repay() external { ... }  // 永不暫停
function deposit() external { ... }  // 永不暫停
function borrow() external whenNotPaused { ... }
function liquidate() external whenNotPaused { ... }
```

### 嚴重性: Medium

---

## Pattern 7: Multi-Collateral Liquidation Ordering

### 描述
支援多種 collateral 的協議，清算時如果沒有正確排序（先清算波動性最高的），可能導致剩餘倉位風險更高。

### 漏洞程式碼
```solidity
function liquidate(address borrower, address collateralToken) external {
    // ❌ 清算人自選 collateral token
    // 會選最值錢/最穩定的 collateral，留下垃圾 collateral
    _seize(borrower, msg.sender, collateralToken, amount);
}
```

### 修復方向
- 強制清算順序（先清算高波動資產）
- 或按比例從所有 collateral 中扣除
- 或給予不同 collateral 不同 liquidation bonus（激勵清算高風險資產）

### 嚴重性: Medium

---

## Pattern 8: Flash Loan Assisted Liquidation Manipulation

### 描述
攻擊者利用 flash loan 操縱 oracle 價格，使健康倉位暫時看起來 unhealthy 並清算。

### 攻擊流程
1. Flash loan 大量資金
2. 砸盤 collateral token（或在 AMM-based oracle 中操縱）
3. 清算目標倉位（oracle 顯示 unhealthy）
4. 回購 collateral token
5. 歸還 flash loan，獲利

### 防護
- 使用 TWAP oracle（不受單筆交易影響）
- Chainlink 等外部 oracle（難以操縱）
- 清算前要求多個區塊的價格確認

### 嚴重性: Critical

---

## 檢查清單

審計 liquidation 邏輯時必檢：

- [ ] 是否禁止 self-liquidation？
- [ ] Oracle 價格是否 fresh？
- [ ] LTV < Liquidation Threshold < 100%？
- [ ] 是否有最小清算量？清算後剩餘倉位是否合理？
- [ ] Underwater position（bad debt）如何處理？
- [ ] 暫停狀態下用戶能否自救（還款/存款）？
- [ ] Multi-collateral 清算順序是否合理？
- [ ] Oracle 是否能抵抗 flash loan 操縱？
- [ ] Liquidation bonus 是否過高（可被套利）？
- [ ] Close factor（最大單次清算比例）是否設定？
- [ ] 清算是否正確更新所有相關狀態（利息、rewards）？
