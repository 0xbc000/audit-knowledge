# 獎勵重複領取 (Reward Double-Claim)

## 類別
- **類型**: 業務邏輯 / 獎勵分配
- **嚴重性**: High / Critical
- **常見於**: Staking, Airdrop, Vesting, MasterChef-style contracts

## 模式描述

獎勵領取函數未在轉帳前正確更新用戶狀態（`rewardDebt`、`lastClaimTime`、`claimed` flag），導致用戶可透過重入或多路徑呼叫重複領取獎勵。

## 核心不變量

```
Σ(userClaimed[i]) <= totalRewardsAllocated
user.rewardDebt 必須在任何 external call 之前更新
```

## 漏洞特徵

### Pattern A: Claim 前未更新 rewardDebt（重入）

```solidity
function claimReward() external {
    uint256 pending = _pendingReward(msg.sender);
    // ❌ rewardDebt 在 external call 之後才更新
    rewardToken.transfer(msg.sender, pending);  // 可重入
    user.rewardDebt = user.amount * accRewardPerShare / PRECISION;
}
```

**攻擊**: 若 `rewardToken` 是 ERC-777 或有 hook 的代幣，`transfer` 時回呼 `claimReward()`，`rewardDebt` 尚未更新，`_pendingReward` 仍回傳全額。

### Pattern B: 多路徑領取（Multiple Entry Points）

```solidity
function harvest() external {
    _distributeReward(msg.sender);
}

function withdraw(uint256 amount) external {
    _distributeReward(msg.sender);  // 同一區塊內再次分配
    _withdraw(msg.sender, amount);
}

function _distributeReward(address user) internal {
    uint256 pending = _pendingReward(user);
    if (pending > 0) {
        rewardToken.transfer(user, pending);
    }
    // ❌ 若 withdraw 和 harvest 在同一交易中被呼叫
    // rewardDebt 基於當前 amount 計算，withdraw 改變 amount 後不重算
    users[user].rewardDebt = users[user].amount * accRewardPerShare / PRECISION;
}
```

### Pattern C: 跨池/跨 epoch 重複領取

```solidity
mapping(uint256 => mapping(address => bool)) public claimed; // epochId => user => claimed

function claim(uint256 epochId) external {
    require(!claimed[epochId][msg.sender], "Already claimed");
    uint256 reward = calculateReward(epochId, msg.sender);
    // ❌ epochId 驗證不嚴格，或 reward 計算包含多個 epoch 的累積
    rewardToken.transfer(msg.sender, reward);
    claimed[epochId][msg.sender] = true;
}
```

## 修復方式

### Fix A: CEI 模式 (Checks-Effects-Interactions)

```solidity
function claimReward() external nonReentrant {
    uint256 pending = _pendingReward(msg.sender);
    require(pending > 0, "Nothing to claim");
    
    // ✅ 先更新狀態
    user.rewardDebt = user.amount * accRewardPerShare / PRECISION;
    
    // 再做 external call
    rewardToken.safeTransfer(msg.sender, pending);
    
    emit RewardClaimed(msg.sender, pending);
}
```

### Fix B: 統一入口 + 原子化更新

```solidity
function _distributeReward(address user) internal {
    uint256 pending = _pendingReward(user);
    if (pending > 0) {
        users[user].rewardDebt = users[user].amount * accRewardPerShare / PRECISION;
        rewardToken.safeTransfer(user, pending);
    }
}

function withdraw(uint256 amount) external nonReentrant {
    _distributeReward(msg.sender);
    users[msg.sender].amount -= amount;
    // ✅ withdraw 後重算 rewardDebt
    users[msg.sender].rewardDebt = users[msg.sender].amount * accRewardPerShare / PRECISION;
    stakingToken.safeTransfer(msg.sender, amount);
}
```

## 檢測規則

```yaml
id: reward-double-claim
severity: high
patterns:
  - pattern_a:
      description: "rewardDebt updated after external call"
      check: "transfer/safeTransfer appears before rewardDebt assignment in same function"
  - pattern_b:
      description: "multiple functions call _distributeReward without atomic state update"
      check: "grep for _distributeReward calls; verify rewardDebt recalculated after amount changes"
  - pattern_c:
      description: "epoch-based claim without cumulative tracking"
      check: "claimed mapping only tracks single epoch; verify no cross-epoch leakage"

audit_questions:
  - "Can the same user receive rewards twice in a single transaction?"
  - "If rewardToken has transfer hooks, is claimReward reentrant-safe?"
  - "After withdraw changes user.amount, is rewardDebt recalculated?"
  - "Are there multiple code paths that trigger reward distribution?"
```

## 真實案例

- **Sentiment V2 (2024)**: Reward distribution 未遵循 CEI，ERC-777 代幣可重入領取
- **Beanstalk (2022)**: 治理提案 + 閃電貸 + 重複投票（類似雙重領取邏輯）
- **多數 MasterChef fork**: 常見 withdraw + harvest 在同一交易中被利用

## 測試模板

```solidity
// Foundry test
function test_doubleClaimViaReentrancy() public {
    // Setup: deploy staking contract with ERC-777-like reward token
    MaliciousReceiver attacker = new MaliciousReceiver(address(staking));
    
    // Stake
    vm.startPrank(address(attacker));
    stakingToken.approve(address(staking), 1000e18);
    staking.stake(1000e18);
    
    // Advance time for rewards
    vm.warp(block.timestamp + 7 days);
    
    uint256 balBefore = rewardToken.balanceOf(address(attacker));
    attacker.attack(); // calls claimReward, which triggers re-entrancy
    uint256 balAfter = rewardToken.balanceOf(address(attacker));
    
    // Should only get 1x reward, not 2x
    uint256 expectedReward = staking.pendingReward(address(attacker));
    assertEq(balAfter - balBefore, expectedReward, "Double claim detected!");
}
```

## 相關模式

- [reward-accumulator-precision](./reward-accumulator-precision.md) — 精度損失導致獎勵消失
- [fee-share-ordering](./fee-share-ordering.md) — 費用分配順序問題
- [reentrancy](../reentrancy/) — 通用重入模式
