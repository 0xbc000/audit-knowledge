# 獎勵累加器精度損失 (Reward Accumulator Precision Loss)

## 類別
- **類型**: 數學 / 獎勵分配
- **嚴重性**: Medium / High
- **常見於**: Staking, Yield Farming, MasterChef-style contracts

## 模式描述

獎勵累加器（`rewardPerTokenStored` / `accRewardPerShare`）在更新時因整數除法導致精度損失。當 `totalSupply` 遠大於 `rewardRate * elapsed` 時，增量被截斷為 0，獎勵永久消失。

## 核心不變量

```
totalRewardsDistributed == Σ(userRewardsClaimed) + undistributed
```

若累加器更新被截斷，`undistributed` 只增不減 → 用戶永遠無法提取的獎勵。

## 漏洞特徵

```solidity
// ❌ 精度不足：當 totalStaked >> rewardRate * timeElapsed 時截斷為 0
function updateReward() internal {
    uint256 elapsed = block.timestamp - lastUpdateTime;
    // 若 rewardRate = 1e18, elapsed = 1, totalStaked = 1e27
    // delta = 1e18 * 1 / 1e27 = 0  ← 截斷！
    rewardPerTokenStored += (rewardRate * elapsed) / totalStaked;
    lastUpdateTime = block.timestamp;
}

// ✅ 使用精度乘數防止截斷
uint256 constant PRECISION = 1e18;

function updateReward() internal {
    uint256 elapsed = block.timestamp - lastUpdateTime;
    // delta = 1e18 * 1 * 1e18 / 1e27 = 1e9  ← 保留精度
    rewardPerTokenStored += (rewardRate * elapsed * PRECISION) / totalStaked;
    lastUpdateTime = block.timestamp;
}

function earned(address user) public view returns (uint256) {
    return (balanceOf[user] * (rewardPerTokenStored - userRewardPerTokenPaid[user])) / PRECISION;
}
```

## 變種

### 1. 精度乘數不夠大

```solidity
// ❌ PRECISION = 1e12 對高 TVL 池不夠
uint256 constant PRECISION = 1e12;
// totalStaked = 1e30 (1T tokens with 18 decimals)
// rewardRate = 1e16/s
// delta = 1e16 * 1 * 1e12 / 1e30 = 0  ← 還是截斷

// ✅ 使用 1e18 或更大
uint256 constant PRECISION = 1e18;
// delta = 1e16 * 1 * 1e18 / 1e30 = 1e4  ← 安全
```

### 2. 多代幣獎勵精度不一致

```solidity
// ❌ 對所有 reward token 用相同精度
// USDC (6 decimals) vs WETH (18 decimals) 需要不同精度
mapping(address => uint256) rewardPerTokenStored;

// ✅ 根據 token decimals 調整或使用足夠大的統一精度
uint256 constant PRECISION = 1e36; // 覆蓋所有情況
```

### 3. 累加器溢出

```solidity
// ❌ 累加器可能溢出（Solidity 0.8+ 會 revert，凍結合約）
// rewardPerTokenStored 持續累加，若 PRECISION 太大 + 時間長
// uint256 max = 1.15e77
// 若 PRECISION = 1e36, rewardRate = 1e18, totalStaked = 1
// 每秒增加 1e54 → ~1e23 秒後溢出 (實際上安全，但需驗證)

// ✅ 驗證：maxAccumulator = rewardRate * maxDuration * PRECISION / minTotalStaked
// 確保 < type(uint256).max
```

## 檢測模式

### 必查項目
1. **精度乘數是否存在？** — 無乘數幾乎必定有損失
2. **乘數大小是否足夠？** — 計算 `rewardRate * 1 * PRECISION / maxTotalSupply`，結果需 > 0
3. **除法位置** — 除法應在最後（先乘後除）
4. **累加器是否可能溢出？** — 計算最大值是否超過 uint256

### 自動檢測 heuristic
```
MATCH: function contains `rewardPerToken` or `accRewardPerShare`
  AND: division by `totalSupply` or `totalStaked`
  CHECK: numerator does NOT contain multiplication by constant >= 1e18
  → FLAG: potential precision loss
```

## 真實案例

### Synthetix StakingRewards (經典參考實現)
- 使用 `1e18` 精度乘數
- `rewardPerToken()` = `rewardPerTokenStored + (rewardRate * (lastTimeRewardApplicable - lastUpdateTime) * 1e18 / totalSupply)`
- 業界標準，但許多 fork 在修改時引入精度問題

### MasterChef v1 (SushiSwap)
- 使用 `accSushiPerShare` with `1e12` 精度
- 對大多數情況足夠，但極端 TVL 下有邊際損失
- MasterChef v2 改進了精度處理

### 常見 audit finding 場景
- Protocol fork Synthetix 但移除或降低 PRECISION
- 多幣種獎勵系統中對低 decimals token（USDC/USDT）精度不足
- 動態 rewardRate 更新頻率過高，每次都有微小截斷累積

## 修復建議

1. **始終使用 >= 1e18 的精度乘數**
2. **先乘後除**（把所有乘法放在除法之前）
3. **考慮最壞情況**：最大 totalSupply + 最小 rewardRate + 最短 elapsed
4. **對不同 decimals 的 reward token 分別處理精度**
5. **加入 dust 回收機制**：允許 admin 提取因精度損失而卡在合約的微量代幣

## 相關模式
- [interest-calculation-mismatch](../math/interest-calculation-mismatch.md)
- [fee-share-ordering](./fee-share-ordering.md)
