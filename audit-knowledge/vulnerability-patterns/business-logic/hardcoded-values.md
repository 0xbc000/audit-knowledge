# 硬編碼關鍵值 (Hardcoded Critical Values)

## 類別
- **類型**: 業務邏輯漏洞
- **嚴重性**: High / Critical
- **常見於**: DeFi 協議、交換/兌換系統

## 模式描述

協議使用硬編碼的值來代替應該動態計算的關鍵參數（如匯率、價格、費率等）。

## 漏洞特徵

```solidity
// ❌ 錯誤：硬編碼匯率
function getExchangeRate() public view returns (uint256) {
    return 1e18;  // 永遠返回 1:1
}

// ❌ 更糟：註釋掉真正的計算邏輯
function getExchangeRate() public view returns (uint256) {
    // uint256 totalDeCRVUSD = deToken.totalSupply();
    // uint256 totalRcrvUSD = rToken.balanceOf(address(this));
    // return (totalRcrvUSD * scalingFactor) / totalDeCRVUSD;
    return 1e18;  // ← 臨時硬編碼，忘了改回來
}

// ✅ 正確：動態計算
function getExchangeRate() public view returns (uint256) {
    uint256 totalDebt = deToken.totalSupply();
    uint256 totalAssets = rToken.balanceOf(address(this));
    if (totalDebt == 0) return 1e18;  // 初始匯率
    return (totalAssets * 1e18) / totalDebt;
}
```

## 真實案例

### RAAC (2025-02 CodeHawks)

**檔案**: `StabilityPool.sol` → `getExchangeRate`

```solidity
function getExchangeRate() public view returns (uint256) {
    // 這些是正確的計算邏輯，但被註釋掉了！
    // uint256 totalDeCRVUSD = deToken.totalSupply();
    // uint256 totalRcrvUSD = rToken.balanceOf(address(this));
    // if (totalDeCRVUSD == 0 || totalRcrvUSD == 0) return 10**18;
    // return (totalRcrvUSD * scalingFactor) / totalDeCRVUSD;
    
    return 1e18;  // ❌ 永遠返回 1:1
}
```

**使用場景**:
```solidity
// 計算要 mint 多少 deToken
function calculateDeCRVUSDAmount(uint256 rcrvUSDAmount) public view returns (uint256) {
    return (rcrvUSDAmount * scalingFactor) / getExchangeRate();
    // ↑ 因為 getExchangeRate() 永遠是 1e18，計算結果錯誤
}
```

**影響**:
- 匯率不反映真實市場情況
- 套利攻擊：攻擊者可以用錯誤的匯率兌換
- 用戶資金損失
- 協議可能 insolvency

## 常見變體

### 1. 測試遺留
```solidity
// 開發時為了方便測試，忘了改回來
uint256 public constant PRICE = 1000;
```

### 2. TODO 未完成
```solidity
function getPrice() public view returns (uint256) {
    // TODO: integrate with oracle
    return 100e18;
}
```

### 3. 臨時繞過
```solidity
function getInterestRate() public view returns (uint256) {
    // Temporary fix for mainnet launch
    return 5e16;  // 5%
}
```

## 檢測方法

### 1. 靜態分析
```bash
# 找返回常數的 view 函數
grep -rn "function get.*view.*returns" contracts/ | \
  xargs grep -l "return [0-9]"
```

### 2. 關鍵字搜索
```bash
grep -rn "TODO\|FIXME\|temporary\|hardcode" contracts/
```

### 3. 對比註釋與程式碼
如果看到大量被註釋掉的計算邏輯，加上簡單的 return，高度可疑。

### 4. Prompt Template
```markdown
## 分析這個函數

[貼上程式碼]

## 問題
1. 返回值是動態計算的還是固定的？
2. 如果是固定的，這在業務邏輯上合理嗎？
3. 有沒有被註釋掉的程式碼？為什麼？
4. 這個值應該根據什麼因素變化？
```

## 預防措施

1. **代碼審查 checklist**
   - [ ] 所有 `TODO`/`FIXME` 已處理
   - [ ] 沒有被註釋掉的關鍵邏輯
   - [ ] 常數值有文檔說明

2. **測試覆蓋**
```solidity
function test_exchangeRateChangesWithBalance() public {
    // 確保匯率會隨著餘額變化
    uint256 rate1 = pool.getExchangeRate();
    pool.deposit(1000e18);
    uint256 rate2 = pool.getExchangeRate();
    assertNotEq(rate1, rate2);  // 應該不同
}
```

3. **CI 檢查**
```yaml
# 禁止合併含有 TODO 的程式碼
- run: |
    if grep -rn "TODO\|FIXME" contracts/; then
      exit 1
    fi
```

## 相關漏洞
- [Magic Numbers](./magic-numbers.md)
- [Commented Code](./commented-code.md)

## 標籤
`business-logic` `hardcoded` `exchange-rate` `high-severity`
