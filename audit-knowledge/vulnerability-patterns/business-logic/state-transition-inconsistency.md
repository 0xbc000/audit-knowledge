# 狀態轉換不一致 (State Transition Inconsistency)

## 類別
- **類型**: 業務邏輯漏洞
- **嚴重性**: High / Critical
- **常見於**: Lending, Staking, Governance, NFT Marketplace, Escrow

## 模式描述

協議中存在隱含的狀態機（如：訂單的 Open → Filled → Cancelled、借貸的 Active → Liquidatable → Closed），但沒有明確強制狀態轉換規則，導致用戶可以跳過步驟、重複執行、或在非法狀態下操作。

## 漏洞特徵

```solidity
// ❌ 錯誤：沒有檢查當前狀態，允許無效轉換
enum OrderStatus { Open, Filled, Cancelled }

mapping(uint256 => OrderStatus) public orderStatus;

function fillOrder(uint256 orderId) external {
    // 沒檢查 orderStatus[orderId] == Open
    orderStatus[orderId] = OrderStatus.Filled;
    _transferAssets(orderId);
}

function cancelOrder(uint256 orderId) external {
    // 沒檢查 orderStatus[orderId] == Open
    orderStatus[orderId] = OrderStatus.Cancelled;
    _refundDeposit(orderId);
}
// 攻擊路徑：先 fillOrder（取得資產）再 cancelOrder（拿回保證金）
```

```solidity
// ✅ 正確：嚴格的狀態轉換
function fillOrder(uint256 orderId) external {
    require(orderStatus[orderId] == OrderStatus.Open, "not open");
    orderStatus[orderId] = OrderStatus.Filled;
    _transferAssets(orderId);
}

function cancelOrder(uint256 orderId) external {
    require(orderStatus[orderId] == OrderStatus.Open, "not open");
    orderStatus[orderId] = OrderStatus.Cancelled;
    _refundDeposit(orderId);
}
```

## 常見變體

### 1. 清算後仍可操作 (Post-Liquidation Actions)
```solidity
// ❌ 借貸協議：用戶被清算後仍能 withdraw 剩餘抵押品
function withdraw(uint256 positionId, uint256 amount) external {
    Position storage pos = positions[positionId];
    require(pos.owner == msg.sender, "not owner");
    // 缺少: require(pos.status == Status.Active, "not active");
    pos.collateral -= amount;
    token.transfer(msg.sender, amount);
}
```

### 2. 重複執行 (Double Execution)
```solidity
// ❌ 治理提案可以被多次執行
function execute(uint256 proposalId) external {
    Proposal storage p = proposals[proposalId];
    require(p.votesFor > p.votesAgainst, "not passed");
    require(block.timestamp > p.endTime, "not ended");
    // 缺少: require(!p.executed, "already executed");
    // 缺少: p.executed = true;
    _executeActions(p.actions);
}
```

### 3. 時間窗口競爭 (Race Between States)
```solidity
// ❌ auction 結束後仍可出價
function bid(uint256 auctionId) external payable {
    Auction storage a = auctions[auctionId];
    require(msg.value > a.highestBid, "too low");
    // 缺少: require(block.timestamp < a.endTime, "ended");
    // 缺少: require(a.status == Status.Active, "not active");
    _refundPreviousBidder(auctionId);
    a.highestBid = msg.value;
    a.highestBidder = msg.sender;
}
```

### 4. 部分狀態更新 (Partial State Update)
```solidity
// ❌ 更新了一個映射但忘了更新另一個
function closePosition(uint256 positionId) external {
    positions[positionId].status = Status.Closed;
    // 缺少: delete userPositions[msg.sender][positionId];
    // 用戶仍然可以通過 userPositions 枚舉到已關閉的頭寸
}
```

## 真實案例

### Wise Lending (2024) — 清算後殘餘操作
清算函數沒有完全清除借貸頭寸的所有相關狀態，被清算用戶仍可調用部分函數操作殘餘數據，導致協議會計不一致。

### Beanstalk (2022) — 治理提案重複利用
閃電貸攻擊中，攻擊者利用治理狀態轉換的時間窗口，在同一區塊內完成提案 + 投票 + 執行，繞過正常的時間鎖。

### SushiSwap MISO (2021) — 拍賣狀態繞過
荷蘭拍賣的結算邏輯允許在特定條件下重複調用 commitments，因為狀態檢查不完整。

## 檢測方法

### 1. 畫出狀態機圖
```
對每個有 enum 或 bool 狀態的實體：
1. 列出所有可能的狀態
2. 列出所有可以改變狀態的函數
3. 檢查每個函數是否驗證 "from" 狀態
4. 檢查是否存在跳過中間狀態的路徑
```

### 2. 靜態分析
```bash
# 找 enum 定義
grep -rn "enum.*{" contracts/

# 找狀態賦值但沒有前置檢查的函數
grep -B5 "= Status\." contracts/ | grep -v "require\|if ("
```

### 3. Prompt Template
```markdown
## 狀態機分析

[貼上包含 enum 或狀態標記的合約]

## 請分析
1. 這個合約有哪些隱含的狀態機？
2. 畫出每個狀態機的完整轉換圖
3. 哪些函數改變狀態？它們是否驗證當前狀態？
4. 是否存在跳過步驟、重複執行或無效轉換的路徑？
5. 是否所有相關的映射/數組在狀態轉換時都被正確更新？
```

### 4. Invariant 測試
```solidity
// Foundry invariant: 已 Filled 或 Cancelled 的訂單不能再被操作
function invariant_terminalStatesAreImmutable() public {
    for (uint i = 0; i < orderIds.length; i++) {
        OrderStatus s = market.orderStatus(orderIds[i]);
        if (s == OrderStatus.Filled || s == OrderStatus.Cancelled) {
            // 嘗試 fill / cancel 應該 revert
            vm.expectRevert();
            market.fillOrder(orderIds[i]);
            vm.expectRevert();
            market.cancelOrder(orderIds[i]);
        }
    }
}
```

## 預防措施

1. **明確的狀態機模式**
```solidity
modifier onlyInState(uint256 id, Status expected) {
    require(status[id] == expected, "invalid state");
    _;
}

function fill(uint256 id) external onlyInState(id, Status.Open) {
    status[id] = Status.Filled;
    // ...
}
```

2. **Terminal state 不可變**
```solidity
modifier notTerminal(uint256 id) {
    require(
        status[id] != Status.Filled && 
        status[id] != Status.Cancelled,
        "terminal state"
    );
    _;
}
```

3. **全面的狀態清理**
```solidity
function _closePosition(uint256 id) internal {
    positions[id].status = Status.Closed;
    delete userPositions[positions[id].owner][id];
    delete positionCollateral[id];
    // 確保所有相關映射都被清理
}
```

## 審計 Checklist

- [ ] 合約中所有 enum / bool 狀態標記已識別
- [ ] 每個狀態轉換函數都驗證 "from" 狀態
- [ ] 終態 (Filled/Cancelled/Closed) 不允許任何進一步操作
- [ ] 沒有跳過中間狀態的路徑
- [ ] 狀態轉換時所有相關映射/數組都被更新
- [ ] 時間相關的狀態轉換有正確的 timestamp 檢查
- [ ] 存在防止重複執行的機制 (executed flag, nonce)

## 相關漏洞
- [Comparison Operator Inversion](./comparison-operator-inversion.md)
- [Auction First Bid](./auction-first-bid.md)
- [Reentrancy](../reentrancy/reentrancy-patterns.md) — 重入可繞過狀態檢查

## 標籤
`business-logic` `state-machine` `double-execution` `missing-check` `high-severity`
