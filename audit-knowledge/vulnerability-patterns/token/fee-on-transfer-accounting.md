# Fee-on-Transfer Token 記帳漏洞

## 類別
- **類型**: Token 整合漏洞
- **嚴重性**: High
- **常見於**: DEX, Lending, Vault, 任何接受任意 ERC20 的協議

## 模式描述

協議假設 `transferFrom(from, to, amount)` 後，`to` 實際收到 `amount`。但 fee-on-transfer token（如 USDT with fee, STA, PAXG）在轉帳時扣手續費，實際到帳金額 < amount。若協議以 `amount` 而非實際到帳金額記帳，會產生虛增餘額、可被提走超額資金。

## 漏洞特徵

```solidity
// ❌ 錯誤：直接用 amount 記帳
function deposit(address token, uint256 amount) external {
    IERC20(token).transferFrom(msg.sender, address(this), amount);
    balances[msg.sender][token] += amount;  // 實際到帳可能只有 amount * 97%
}

// ✅ 正確：用 before/after 差額記帳
function deposit(address token, uint256 amount) external {
    uint256 before = IERC20(token).balanceOf(address(this));
    IERC20(token).transferFrom(msg.sender, address(this), amount);
    uint256 received = IERC20(token).balanceOf(address(this)) - before;
    balances[msg.sender][token] += received;  // 用實際到帳金額
}
```

## 真實案例

### 1. SushiSwap MasterChef (2020)

用戶存入 fee-on-transfer token，MasterChef 以 `amount` 記錄 `user.amount`。最後一個提款人無法提款（合約餘額不足）。

### 2. Sentiment V2 (2024 Sherlock)

Pool 接受任意 ERC20 作為抵押品，`deposit()` 直接記 `amount`：
```solidity
// Sentiment V2 — Pool.sol
function deposit(uint256 poolId, uint256 assets, ...) external {
    asset.safeTransferFrom(msg.sender, address(this), assets);
    // shares 按 assets 計算，非實際到帳
    uint256 shares = _convertToShares(assets, ...);
    pool.totalDepositAssets += assets;  // ❌ 虛增
}
```

### 3. 常見 Vault 模式

任何繼承 ERC4626 但未覆寫 `deposit()` 的 vault：
```solidity
// OpenZeppelin ERC4626 default — 假設 1:1 transfer
function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {
    uint256 shares = previewDeposit(assets);
    _deposit(_msgSender(), receiver, assets, shares);
    return shares;
}
```
如果底層 asset 有 fee，shares 計算會偏高。

## 影響分析

| 場景 | 影響 |
|------|------|
| Lending pool | 借出金額 > 實際存入，壞帳 |
| Vault/ERC4626 | shares 虛增，後續提款者虧損 |
| DEX/AMM | LP token 虛增，drain liquidity |
| Staking | reward 分配不公，最後 unstake 失敗 |

## 檢測方法

### 1. 靜態搜索

```bash
# 找所有 transferFrom 後直接用 amount 的位置
grep -n "transferFrom" contracts/**/*.sol | \
  xargs -I{} sh -c 'echo "--- {} ---"; grep -A5 "transferFrom" {}'

# 找缺少 balanceOf 差額計算的 deposit/stake 函數
grep -rn "function deposit\|function stake" contracts/ | \
  while read line; do
    file=$(echo "$line" | cut -d: -f1)
    grep -L "balanceOf" "$file" && echo "⚠️  $file: no balanceOf check"
  done
```

### 2. 關鍵問題清單

1. 協議是否接受任意 ERC20？（若只接受 USDC/DAI 等已知 token，風險較低但仍應防禦）
2. `transferFrom` 後是否用 `balanceOf` 差額計算實際到帳？
3. 內部記帳（mapping/struct）是否用 `amount` 參數還是實際差額？
4. 是否有 whitelist 機制排除 fee-on-transfer token？

### 3. Prompt Template

```markdown
## Fee-on-Transfer 分析

函數：
[貼上 deposit/stake/transfer 相關程式碼]

## 問題
1. transferFrom 後，合約用什麼值記帳？amount 還是 balanceOf 差額？
2. 如果 token 有 2% transfer fee，deposit(100) 後 balances 記錄多少？
3. 合約實際持有多少？差額會造成什麼後果？
4. 最後一個 withdraw 的用戶會怎樣？
```

## 修復方式

```solidity
// 方法 1：Before/After pattern（推薦）
function deposit(address token, uint256 amount) external {
    uint256 balBefore = IERC20(token).balanceOf(address(this));
    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);
    uint256 actualReceived = IERC20(token).balanceOf(address(this)) - balBefore;
    
    require(actualReceived > 0, "Zero received");
    balances[msg.sender][token] += actualReceived;
    emit Deposit(msg.sender, token, actualReceived);
}

// 方法 2：明確禁止 fee-on-transfer token
mapping(address => bool) public allowedTokens;
// 只 whitelist 已驗證無 fee 的 token

// 方法 3：ERC4626 覆寫
function deposit(uint256 assets, address receiver) public override returns (uint256) {
    uint256 balBefore = asset.balanceOf(address(this));
    super.deposit(assets, receiver);
    uint256 actualReceived = asset.balanceOf(address(this)) - balBefore;
    // 根據 actualReceived 調整 shares...
}
```

## 變體

### Rebasing Token
類似問題：`balanceOf` 會隨時間改變（如 stETH, aToken）。記帳時不能快取 balance。

### 返回值 bool
部分 token `transfer` 不回傳 bool 或回傳 false 但不 revert（如舊版 USDT）。需用 `safeTransfer`。

## 相關漏洞
- [ERC4626 Inflation Attack](../erc4626/)
- [Reentrancy via Token Callback](../reentrancy/)

## 標籤
`fee-on-transfer` `token` `accounting` `erc20` `high-severity` `deposit` `vault`
