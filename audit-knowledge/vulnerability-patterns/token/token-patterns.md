# ERC20 Token Vulnerability Patterns

> 來源：weird-erc20 repo, Code4rena 審計報告
> 整理：15+ 種怪異 Token 行為及其漏洞

## Overview

ERC20 「標準」定義非常鬆散，很多 token 有意外行為。整合這些 token 時必須格外小心。

---

## 1. Fee-on-Transfer Tokens ⭐ 最常見

**真實案例：** Balancer STA hack - $500K 被盜

**問題：** 轉帳時會扣除手續費，實際收到金額 < 發送金額。

**Token 例子：** STA, PAXG, USDT (可開啟), USDC (可開啟)

**漏洞代碼：**
```solidity
// ❌ 假設收到的金額等於發送的金額
function deposit(uint256 amount) external {
    token.transferFrom(msg.sender, address(this), amount);
    balances[msg.sender] += amount;  // 實際收到的可能是 amount * 0.99
}
```

**正確代碼：**
```solidity
function deposit(uint256 amount) external {
    uint256 balanceBefore = token.balanceOf(address(this));
    token.transferFrom(msg.sender, address(this), amount);
    uint256 actualReceived = token.balanceOf(address(this)) - balanceBefore;
    balances[msg.sender] += actualReceived;  // ✅ 使用實際收到的金額
}
```

---

## 2. Rebasing Tokens ⭐ 隱蔽

**真實案例：** THORChain AMPL exploit

**問題：** 餘額會自動變化（正向或負向），不經過 transfer。

**Token 例子：** AMPL, stETH, aTokens (Aave)

**漏洞場景：**
```solidity
// 用戶存入 100 AMPL
// 負向 rebase 發生，用戶餘額變成 90
// 但合約記錄還是 100
// 用戶提取 100，合約損失 10
```

**防禦方案：**
```solidity
// 方案 1: 使用 shares 而非絕對金額
mapping(address => uint256) public shares;
uint256 public totalShares;

function deposit(uint256 amount) external {
    uint256 sharesToMint = (totalShares == 0) 
        ? amount 
        : amount * totalShares / token.balanceOf(address(this));
    shares[msg.sender] += sharesToMint;
    totalShares += sharesToMint;
    token.transferFrom(msg.sender, address(this), amount);
}

// 方案 2: 使用 wrapper token (如 wstETH)
```

---

## 3. Missing Return Values

**問題：** 某些 token 的 transfer/approve 不返回 bool。

**Token 例子：** USDT, BNB, OMG

**漏洞代碼：**
```solidity
// ❌ 會 revert，因為 USDT 不返回 bool
bool success = IERC20(usdt).transfer(to, amount);
require(success, "Transfer failed");
```

**正確代碼：**
```solidity
// ✅ 使用 SafeERC20
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
using SafeERC20 for IERC20;

token.safeTransfer(to, amount);
```

---

## 4. Approval Race Condition

**問題：** 某些 token 不允許從非零值 approve 到另一個非零值。

**Token 例子：** USDT, KNC

**漏洞代碼：**
```solidity
// 當前 allowance = 100
// ❌ 直接改成 200 會 revert
token.approve(spender, 200);
```

**正確代碼：**
```solidity
// ✅ 先設為 0，再設為目標值
token.safeApprove(spender, 0);
token.safeApprove(spender, 200);

// 或使用 forceApprove (OZ 5.0+)
token.forceApprove(spender, 200);
```

---

## 5. Reentrant Tokens (ERC777)

**真實案例：** imBTC Uniswap hack, lendf.me hack

**問題：** ERC777 token 在 transfer 時會調用接收者的 hook。

**Token 例子：** imBTC, 任何 ERC777

**防禦：**
```solidity
// ✅ 使用 ReentrancyGuard
function deposit(uint256 amount) external nonReentrant {
    // ...
}
```

---

## 6. Tokens with Blocklists

**問題：** 某些 token 有黑名單功能，被封鎖的地址無法轉帳。

**Token 例子：** USDC, USDT

**風險：**
- 合約地址可能被加入黑名單
- 資金可能被永久凍結

**緩解：**
- 文檔中警告用戶風險
- 考慮使用非中心化穩定幣作為備選

---

## 7. Pausable Tokens

**問題：** 某些 token 可以被暫停。

**Token 例子：** BNB, ZIL

**風險：**
- 當 token 暫停時，所有 transfer 會 revert
- 可能導致協議功能失效

---

## 8. Low/High Decimals

**問題：** 精度問題可能導致計算錯誤。

**Token 例子：**
- 低精度：USDC (6), WBTC (8), GUSD (2)
- 高精度：YAM-V2 (24)

**漏洞範例：**
```solidity
// ❌ 假設所有 token 都是 18 decimals
uint256 price = amount * 1e18 / tokenAmount;

// ✅ 使用實際 decimals
uint256 decimals = IERC20Metadata(token).decimals();
uint256 price = amount * (10 ** decimals) / tokenAmount;
```

---

## 9. Upgradable Tokens

**問題：** Token 邏輯可以被修改。

**Token 例子：** USDC, USDT

**風險：**
- 升級後行為可能改變
- 可能打破依賴舊行為的合約

**防禦：**
```solidity
// 類似 MakerDAO 的 TUSD adapter
// 檢測升級並凍結交互
address public currentImplementation;

modifier checkUpgrade() {
    require(
        getImplementation(token) == currentImplementation,
        "Token upgraded, interaction frozen"
    );
    _;
}
```

---

## 10. Flash Mintable Tokens

**問題：** 某些 token 可以在一個交易內無限 mint。

**Token 例子：** DAI

**風險：**
- totalSupply 可能暫時達到 type(uint256).max
- 可能觸發溢出或意外行為

---

## 11. Multiple Token Addresses (Proxied Tokens)

**問題：** 同一個 token 可能有多個地址。

**漏洞範例：**
```solidity
mapping(address => bool) public isPoolToken;

constructor(address tokenA) {
    isPoolToken[tokenA] = true;
}

// ❌ 攻擊者可以用 token 的另一個地址繞過檢查
function rescueFunds(address token, uint amount) external onlyOwner {
    require(!isPoolToken[token], "Cannot rescue pool token");
    IERC20(token).transfer(msg.sender, amount);
}
```

---

## 12. Revert on Zero Value

**問題：** 某些 token 不允許 0 值轉帳或 approve。

**Token 例子：** LEND (transfer), BNB (approve)

```solidity
// ❌ 可能 revert
if (amount > 0) {
    token.transfer(to, amount);
}
// 應該先檢查
```

---

## 13. Non-Standard Return Values

**問題：** 某些 token 即使成功也返回 false。

**Token 例子：** Tether Gold (XAUt)

```solidity
// ❌ 即使轉帳成功也會 revert
bool success = token.transfer(to, amount);
require(success, "Transfer failed");

// ✅ 使用 SafeERC20，它處理了這種情況
token.safeTransfer(to, amount);
```

---

## 14. Native Currency as ERC20

**真實案例：** Uniswap V4 CELO vulnerability

**問題：** 某些鏈上原生幣也有 ERC20 表示，可能導致雙重支付。

**例子：**
- Celo: CELO (0x471ece...)
- Polygon: POL (0x0...1010)
- zkSync: ETH (0x0...800A)

---

## 15. Unusual Permit Functions

**問題：** 某些 token 的 permit 不遵循 EIP-2612。

**Token 例子：** DAI, RAI, CHAI

**風險：** 不支持 permit 的 token 可能不 revert，導致後續代碼意外執行。

---

## 審計 Checklist

| # | 檢查項目 | 嚴重性 |
|---|---------|--------|
| 1 | 是否處理 fee-on-transfer？ | High |
| 2 | 是否處理 rebasing tokens？ | High |
| 3 | 是否使用 SafeERC20？ | High |
| 4 | approve 是否先設為 0？ | Medium |
| 5 | 是否有 reentrancy 防護？ | High |
| 6 | 是否處理不同 decimals？ | Medium |
| 7 | 是否考慮 token 升級風險？ | Low |
| 8 | 是否考慮黑名單/暫停風險？ | Medium |
| 9 | 是否處理 0 值 transfer？ | Low |
| 10 | 是否考慮 flash mint？ | Medium |

---

## 常用防禦模式

### 1. SafeERC20
```solidity
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
using SafeERC20 for IERC20;

token.safeTransfer(to, amount);
token.safeTransferFrom(from, to, amount);
token.forceApprove(spender, amount);
```

### 2. 實際餘額檢查
```solidity
uint256 balanceBefore = token.balanceOf(address(this));
token.safeTransferFrom(from, address(this), amount);
uint256 actualReceived = token.balanceOf(address(this)) - balanceBefore;
```

### 3. Token 白名單
```solidity
mapping(address => bool) public supportedTokens;

function deposit(address token, uint256 amount) external {
    require(supportedTokens[token], "Token not supported");
    // ...
}
```

---

## Minimal Reproduction (Pattern 1: Fee-on-Transfer)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract FeeToken is ERC20 {
    uint256 public constant FEE_BPS = 100; // 1%
    constructor() ERC20("FeeToken", "FT") { _mint(msg.sender, 1e24); }

    function _update(address from, address to, uint256 amt) internal override {
        if (from != address(0) && to != address(0)) {
            uint256 fee = amt * FEE_BPS / 10000;
            super._update(from, address(0), fee); // burn fee
            super._update(from, to, amt - fee);
        } else {
            super._update(from, to, amt);
        }
    }
}

contract VulnerablePool {
    FeeToken public token;
    mapping(address => uint256) public balances;

    constructor(FeeToken _t) { token = _t; }

    function deposit(uint256 amount) external {
        token.transferFrom(msg.sender, address(this), amount);
        balances[msg.sender] += amount; // ❌ records full amount
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        token.transfer(msg.sender, amount);
    }
}
```

### Foundry Test Draft

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

// paste FeeToken and VulnerablePool above

contract FeeOnTransferTest is Test {
    FeeToken token;
    VulnerablePool pool;
    address alice = makeAddr("alice");

    function setUp() public {
        token = new FeeToken();
        pool = new VulnerablePool(token);
        token.transfer(alice, 1000e18);
    }

    function testFeeOnTransferAccounting() public {
        vm.startPrank(alice);
        token.approve(address(pool), 1000e18);
        pool.deposit(1000e18);
        // Pool recorded 1000 but only received 990
        uint256 actual = token.balanceOf(address(pool));
        uint256 recorded = pool.balances(alice);
        assertGt(recorded, actual, "recorded > actual = insolvency");
        vm.stopPrank();
    }
}
```

---

## 參考資源

- [weird-erc20 Repository](https://github.com/d-xo/weird-erc20)
- [Trail of Bits Token Integration Checklist](https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/token_integration.md)
- [Consensys Token Checklist](https://consensys.net/diligence/blog/2020/11/token-interaction-checklist/)
