# Math/Arithmetic Vulnerability Patterns

> 來源：Code4rena, Sherlock, OWASP 2021-2024
> 整理：5 個 High/Medium Severity 類型

## Overview

數學運算漏洞在 DeFi 中極為常見。精度損失、溢出、除零等問題可能導致嚴重的資金損失。

---

## 1. Precision Loss (精度損失) ⭐ 最常見

**問題：** 整數除法會向下取整，導致精度損失。

### 1.1 除法在乘法之前

**漏洞代碼：**
```solidity
// ❌ 先除後乘，損失精度
uint256 reward = totalReward / totalShares * userShares;
// 如果 totalReward = 100, totalShares = 300, userShares = 100
// 結果: 100 / 300 = 0, 0 * 100 = 0 (應該是 33)
```

**正確代碼：**
```solidity
// ✅ 先乘後除
uint256 reward = totalReward * userShares / totalShares;
// 結果: 100 * 100 / 300 = 33
```

### 1.2 多次除法累積誤差

**漏洞代碼：**
```solidity
// ❌ 每次除法都損失精度
uint256 step1 = amount / factor1;
uint256 step2 = step1 / factor2;
uint256 result = step2 / factor3;
```

**正確代碼：**
```solidity
// ✅ 合併計算
uint256 result = amount / (factor1 * factor2 * factor3);
// 或使用高精度中間值
```

### 1.3 百分比計算

**漏洞代碼：**
```solidity
// ❌ 小金額會損失精度
uint256 fee = amount * feePercent / 100;
// 如果 amount = 99, feePercent = 1
// 結果: 99 * 1 / 100 = 0
```

**正確代碼：**
```solidity
// ✅ 使用更高精度的基數
uint256 FEE_PRECISION = 10000;  // basis points
uint256 fee = amount * feePercent / FEE_PRECISION;
```

---

## 2. Rounding Errors (取整錯誤)

**問題：** 取整方向錯誤可能導致套利或資金損失。

### 取整規則

| 操作 | 應該有利於 | 取整方向 |
|------|-----------|----------|
| 用戶存入 → 獲得 shares | 協議 | 向下 |
| 用戶提取 → 消耗 shares | 協議 | 向上 |
| 計算費用 | 協議 | 向上 |
| 計算獎勵 | 協議 | 向下 |

**漏洞代碼：**
```solidity
// ❌ 存入時向上取整，用戶獲利
function deposit(uint256 assets) returns (uint256 shares) {
    shares = (assets * totalSupply + totalAssets - 1) / totalAssets;  // 向上
}
```

**正確代碼：**
```solidity
// ✅ 使用 OpenZeppelin Math
import "@openzeppelin/contracts/utils/math/Math.sol";

function deposit(uint256 assets) returns (uint256 shares) {
    shares = Math.mulDiv(assets, totalSupply, totalAssets, Math.Rounding.Down);
}
```

---

## 3. Overflow/Underflow (溢出/下溢)

**Solidity 版本差異：**
- `< 0.8.0`: 需要 SafeMath，否則靜默溢出
- `≥ 0.8.0`: 預設檢查，溢出會 revert
- `unchecked { }`: 關閉檢查，可能有意為之

### 3.1 經典下溢攻擊 (< 0.8.0)

**漏洞代碼：**
```solidity
// Solidity < 0.8.0
// ❌ 下溢：0 - 1 = 2^256 - 1
function withdraw(uint256 amount) {
    balances[msg.sender] -= amount;  // 沒有餘額檢查
    token.transfer(msg.sender, amount);
}
```

**正確代碼：**
```solidity
// ✅ 使用 SafeMath 或 Solidity >= 0.8.0
function withdraw(uint256 amount) {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    balances[msg.sender] -= amount;
    token.transfer(msg.sender, amount);
}
```

### 3.2 乘法溢出

**漏洞代碼：**
```solidity
// ❌ 大數相乘可能溢出
uint256 result = price * amount * multiplier;
```

**正確代碼：**
```solidity
// ✅ 使用 mulDiv 避免中間溢出
uint256 result = Math.mulDiv(price, amount, PRECISION);
result = result * multiplier;
```

### 3.3 Unchecked 區塊風險

**漏洞代碼：**
```solidity
// ❌ unchecked 中的溢出不會 revert
unchecked {
    for (uint256 i = 0; i < users.length; i++) {
        rewards[users[i]] += userReward;  // 可能溢出！
    }
}
```

**正確代碼：**
```solidity
// ✅ 只對確定不會溢出的操作使用 unchecked
for (uint256 i = 0; i < users.length;) {
    rewards[users[i]] += userReward;  // 在 checked 區域
    unchecked { ++i; }  // i++ 不會溢出
}
```

---

## 4. Division by Zero (除零)

**問題：** 除以零會導致交易 revert。

**漏洞場景：**
```solidity
function getPrice() returns (uint256) {
    // ❌ 如果 totalSupply == 0，會 revert
    return totalAssets * 1e18 / totalSupply;
}
```

**正確代碼：**
```solidity
function getPrice() returns (uint256) {
    if (totalSupply == 0) {
        return 1e18;  // 預設價格
    }
    return totalAssets * 1e18 / totalSupply;
}
```

---

## 5. Flash Loan Price Manipulation (閃電貸價格操縱)

**真實案例：** Spectra IBT Vault Deflation Attack

**問題：** 閃電貸可以暫時改變池子狀態，操縱基於池子狀態的計算。

**攻擊流程 (Spectra)：**
```
1. 閃電貸借走 IBT vault 的所有 shares
2. Redeem 所有 shares，vault 變空
3. Vault 價格回到預設值 (1:1)
4. 用低價 mint 回 shares + 手續費
5. 還閃電貸
6. 攻擊者獲得所有累積收益
```

**防禦：**
```solidity
function flashLoan(...) external returns (bool) {
    uint256 initialRate = vault.convertToAssets(1e18);
    
    // 執行閃電貸...
    
    uint256 postRate = vault.convertToAssets(1e18);
    require(postRate >= initialRate, "Rate manipulation detected");
    
    return true;
}
```

---

## 常見高風險計算場景

### 1. 利率計算
```solidity
// ✅ 使用複利公式
// (1 + r/n)^(nt) - 可能需要指數庫
import "@prb/math/contracts/PRBMathUD60x18.sol";
```

### 2. 價格換算 (不同精度)
```solidity
// Token A: 6 decimals, Token B: 18 decimals
function convert(uint256 amountA) returns (uint256 amountB) {
    // ✅ 正確處理精度差異
    return amountA * 10**(18-6) * priceB / priceA;
}
```

### 3. LP Token 份額計算
```solidity
// ✅ 使用幾何平均數避免操縱
uint256 liquidity = Math.sqrt(amount0 * amount1);
```

---

## 審計 Checklist

| # | 檢查項目 | 嚴重性 |
|---|---------|--------|
| 1 | 是否有除法在乘法之前？ | High |
| 2 | 除數是否可能為 0？ | High |
| 3 | 取整方向是否正確？ | High |
| 4 | unchecked 區塊是否安全？ | High |
| 5 | 跨精度計算是否正確？ | Medium |
| 6 | 是否有閃電貸操縱風險？ | High |
| 7 | 複利計算是否正確？ | Medium |
| 8 | 大數乘法是否可能溢出？ | Medium |

---

## 實用工具庫

### OpenZeppelin Math
```solidity
import "@openzeppelin/contracts/utils/math/Math.sol";

// mulDiv: a * b / c，避免中間溢出
Math.mulDiv(a, b, c, Math.Rounding.Down);

// 平方根
Math.sqrt(x);

// 最大/最小值
Math.max(a, b);
Math.min(a, b);
```

### PRBMath (高精度)
```solidity
import "@prb/math/contracts/PRBMathUD60x18.sol";

// 指數運算
PRBMathUD60x18.exp(x);

// 對數
PRBMathUD60x18.ln(x);

// 次方
PRBMathUD60x18.pow(x, y);
```

### ABDKMath64x64
```solidity
import "abdk-libraries-solidity/ABDKMath64x64.sol";

// 適合高精度計算
int128 result = ABDKMath64x64.mul(a, b);
```

---

## 參考資源

- [OWASP Integer Overflow/Underflow](https://owasp.org/www-project-smart-contract-top-10/2023/en/src/SC02-integer-overflow-underflow.html)
- [OpenZeppelin Math Library](https://docs.openzeppelin.com/contracts/4.x/api/utils#Math)
- [PRBMath Documentation](https://github.com/PaulRBerg/prb-math)
- [Trail of Bits Math Pitfalls](https://github.com/crytic/building-secure-contracts/blob/master/not-so-smart-contracts/README.md)
