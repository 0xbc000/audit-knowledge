# 利息計算不一致 (Interest Calculation Mismatch)

## 風險等級
**Medium** - 長期累積可導致協議損失

## 描述
存款利息和借款利息使用不同的計算方式（線性 vs 複利），導致協議內部會計不平衡。

## 漏洞模式

```solidity
// ❌ RAAC - ReserveLibrary.sol
function updateReserveState(ReserveData storage reserve, ...) internal {
    // 存款：線性計算
    reserve.liquidityIndex = calculateLiquidityIndex(
        reserve.liquidityIndex,
        liquidityRate,
        timeDelta
    );  // linear: index += rate * time
    
    // 借款：複利計算
    reserve.usageIndex = calculateUsageIndex(
        reserve.usageIndex,
        borrowRate,
        timeDelta
    );  // compound: index *= (1 + rate)^time
}

function calculateLiquidityIndex(...) internal pure returns (uint256) {
    // 線性: newIndex = oldIndex + (oldIndex * rate * time / YEAR)
    return currentIndex + currentIndex.rayMul(rate).rayMul(timeDelta) / SECONDS_PER_YEAR;
}

function calculateUsageIndex(...) internal pure returns (uint256) {
    // 複利: newIndex = oldIndex * (1 + rate * time / YEAR)
    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;
    return currentIndex.rayMul(
        WadRayMath.RAY + ratePerSecond.rayMul(timeDelta)
    );
}
```

## 影響

1. **長期 dust 累積** - 借款收取的利息 > 存款支付的利息
2. **協議盈餘/虧損** - 取決於利用率和時間
3. **套利機會** - 頻繁存取的用戶可能獲利

## 數學分析

假設 10% APY，1 年期：

| 計算方式 | 公式 | 結果 |
|---------|------|------|
| 線性 | 1 + 0.1 = 1.1 | 10% |
| 複利(年) | (1 + 0.1)^1 = 1.1 | 10% |
| 複利(日) | (1 + 0.1/365)^365 ≈ 1.1052 | 10.52% |
| 複利(秒) | (1 + 0.1/31536000)^31536000 ≈ 1.1052 | 10.52% |

**差異**: 約 0.52% 每年

## 檢測方法

### 1. 找利息計算函數
```solidity
// 關鍵字
calculateLiquidityIndex
calculateUsageIndex
calculateInterest
updateIndex
accrueInterest
```

### 2. 比較存款和借款的計算
- 是否使用相同的時間複利方式？
- 是否使用相同的精度？

### 3. Invariant 測試
```solidity
// 長期運行後檢查
function invariant_interest_balance() public {
    uint256 totalSupplied = rToken.totalSupply();
    uint256 totalBorrowed = debtToken.totalSupply();
    uint256 reserveBalance = reserve.balance();
    
    // 協議應該有足夠資金支付所有存款
    assert(reserveBalance + totalBorrowed >= totalSupplied);
}
```

## 修復方式

### 方案 1: 統一使用複利
```solidity
function calculateIndex(uint256 currentIndex, uint256 rate, uint256 timeDelta) 
    internal pure returns (uint256) 
{
    // 兩者都用複利
    uint256 ratePerSecond = rate / SECONDS_PER_YEAR;
    return currentIndex.rayMul(WadRayMath.RAY + ratePerSecond * timeDelta);
}
```

### 方案 2: 統一使用線性
```solidity
// 較簡單但精度較低
function calculateIndex(...) internal pure returns (uint256) {
    return currentIndex + currentIndex * rate * timeDelta / SECONDS_PER_YEAR / RAY;
}
```

### 方案 3: 明確的協議 spread
```solidity
// 如果故意有差異，應明確記錄
uint256 public constant PROTOCOL_SPREAD = 50; // 0.5%
```

## 真實案例

| 專案 | 位置 | 影響 |
|------|------|------|
| RAAC 2025 | ReserveLibrary | 長期 dust 累積 |
| Compound V2 | 設計如此 | 有明確的 reserve factor |
| Aave V2/V3 | 兩者都用複利 | 無此問題 |

## 相關模式
- [rounding-direction.md](./rounding-direction.md) (待新增)
- [precision-loss.md](./precision-loss.md) (待新增)
