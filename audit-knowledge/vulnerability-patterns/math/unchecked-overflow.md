# Unchecked Arithmetic Overflow

## 類別
Math / Integer Safety

## 描述
Solidity 0.8+ 預設有溢出檢查，但 `unchecked` block 會關閉檢查。
開發者常因效能考量或錯誤的假設使用 unchecked，導致溢出漏洞。

## 漏洞模式

### 錯誤假設
```solidity
// 開發者註釋："這不可能溢出"
unchecked {
    // ❌ 實際上可以溢出
    removedLiquidity += chunkLiquidity;
}
```

### 用戶輸入進入 unchecked
```solidity
function previewMint(uint shares) public view returns (uint assets) {
    unchecked {
        // ❌ shares 是用戶輸入，可以很大
        assets = (shares * DECIMALS * totalAssets()) / (totalSupply * factor);
    }
}
```

### 攻擊範例（Panoptic H-02）
```solidity
uint shares = type(uint).max / 10000 + 1;
// shares * DECIMALS 溢出，assets 變很小
uint assets = previewMint(shares);
// 用極少 assets 獲得大量 shares
collateralTracker.mint(shares, attacker);
```

## 常見錯誤假設

1. **"我們控制輸入"** - 實際上用戶可能傳入極端值
2. **"計數器永遠不會那麼大"** - 累積變數可能超出預期
3. **"先檢查再操作"** - 檢查可能被繞過
4. **"這是內部函數"** - 內部函數可能被外部函數以意外方式調用

## 修復方式

### 方案 1：移除 unchecked
```solidity
// 讓 Solidity 默認檢查
removedLiquidity += chunkLiquidity;
```

### 方案 2：顯式檢查
```solidity
unchecked {
    uint newLiquidity = removedLiquidity + chunkLiquidity;
    require(newLiquidity >= removedLiquidity, "overflow");
    removedLiquidity = newLiquidity;
}
```

### 方案 3：限制輸入
```solidity
function mint(uint shares) external {
    require(shares <= maxMint(), "too many shares");
    // ...
}

function maxMint() public view returns (uint) {
    // 計算不會溢出的最大值
    return type(uint128).max / DECIMALS;
}
```

## 檢測方法

1. **搜索 unchecked**：`grep -r "unchecked" contracts/`
2. **分析每個 unchecked block**：
   - 變數來源（用戶輸入？累積值？）
   - 操作類型（加法、乘法更危險）
   - 假設是否成立
3. **Fuzz testing**：用極端值測試

## 真實案例

- **Panoptic 2024 (H-02)** - `shares * DECIMALS` 溢出
- **Panoptic 2024 (M-09)** - `removedLiquidity` 累積溢出

## Checklist

- [ ] 所有 unchecked block 都審查了？
- [ ] 用戶輸入是否進入 unchecked？
- [ ] 累積變數是否在 unchecked 中更新？
- [ ] 假設是否有 invariant test 驗證？
