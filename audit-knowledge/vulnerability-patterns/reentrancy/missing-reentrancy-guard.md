# 缺少重入保護 (Missing Reentrancy Guard)

## 類別
- **類型**: 重入漏洞
- **嚴重性**: High / Critical
- **常見於**: 任何有外部調用的合約

## 模式描述

合約在進行外部調用（ETH 轉帳、外部合約調用）時，沒有使用重入保護機制，攻擊者可以在調用完成前重新進入合約。

## 漏洞特徵

```solidity
// ❌ 錯誤：無重入保護
contract Vulnerable {
    mapping(address => uint256) public balances;
    
    function withdraw() external {
        uint256 amount = balances[msg.sender];
        // 外部調用在狀態更新之前
        payable(msg.sender).transfer(amount);  // ← 可重入點
        balances[msg.sender] = 0;  // 狀態更新太晚
    }
}

// ✅ 正確：使用 ReentrancyGuard
contract Safe is ReentrancyGuard {
    function withdraw() external nonReentrant {
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;  // 先更新狀態
        payable(msg.sender).transfer(amount);
    }
}
```

## 真實案例

### RAAC (2025-02 CodeHawks)

**檔案**: `NFTLiquidator.sol`

合約未繼承 `ReentrancyGuard`，但有多個 ETH 轉帳：

```solidity
// 沒有 nonReentrant modifier！
contract NFTLiquidator is Ownable {  // ❌ 缺少 ReentrancyGuard
    
    function placeBid(uint256 tokenId) external payable {
        // ...
        if (data.highestBidder != address(0)) {
            payable(data.highestBidder).transfer(data.highestBid);  // ← 可重入
        }
        data.highestBid = msg.value;  // 狀態更新在轉帳後
        data.highestBidder = msg.sender;
    }
    
    function buyBackNFT(uint256 tokenId) external payable {
        // 多次 ETH 轉帳，每個都是潛在重入點
        if (data.highestBidder != address(0)) {
            payable(data.highestBidder).transfer(data.highestBid);  // ← 可重入
        }
        delete tokenData[tokenId];
        payable(stabilityPool).transfer(price);  // ← 可重入
        if (msg.value > price) {
            payable(msg.sender).transfer(msg.value - price);  // ← 可重入
        }
    }
}
```

**對比同專案其他合約**:
```solidity
// StabilityPool.sol - 正確使用了 ReentrancyGuard
contract StabilityPool is ReentrancyGuard {
    function deposit(uint256 amount) external nonReentrant { ... }
    function withdraw(uint256 amount) external nonReentrant { ... }
}

// LendingPool.sol - 正確使用了 ReentrancyGuard  
contract LendingPool is ReentrancyGuard {
    function deposit(uint256 amount) external nonReentrant { ... }
}
```

## 檢測方法

### 1. 快速檢查

```bash
# 找所有有 ETH 轉帳但沒有 nonReentrant 的合約
grep -rn "\.transfer\|\.call{value" contracts/ | \
  xargs -I {} grep -L "nonReentrant" {} 2>/dev/null
```

### 2. 對比檢查

```bash
# 列出所有繼承 ReentrancyGuard 的合約
grep -rn "ReentrancyGuard" contracts/

# 列出所有有外部調用的合約
grep -rn "\.transfer\|\.call{value\|\.send(" contracts/
```

### 3. Prompt Template

```markdown
## 重入風險分析

這個合約有外部調用：
[貼上程式碼]

## 檢查
1. 合約是否繼承 ReentrancyGuard？
2. 有外部調用的函數是否有 nonReentrant modifier？
3. 外部調用和狀態更新的順序是否正確？
4. 攻擊者能通過重入獲得什麼？
```

## CEI 模式 (Checks-Effects-Interactions)

即使沒有 ReentrancyGuard，遵循 CEI 模式也能防止大部分重入：

```solidity
function withdraw() external {
    // 1. Checks - 檢查條件
    uint256 amount = balances[msg.sender];
    require(amount > 0, "No balance");
    
    // 2. Effects - 更新狀態
    balances[msg.sender] = 0;
    
    // 3. Interactions - 外部調用
    payable(msg.sender).transfer(amount);
}
```

## 相關漏洞
- [Cross-function Reentrancy](./cross-function-reentrancy.md)
- [Read-only Reentrancy](./read-only-reentrancy.md)

## 標籤
`reentrancy` `high-severity` `external-call` `eth-transfer`
