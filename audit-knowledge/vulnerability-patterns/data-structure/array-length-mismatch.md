# 陣列長度處理錯誤 (Array Length Mismatch)

## 類別
- **類型**: 資料結構漏洞
- **嚴重性**: Medium / High
- **常見於**: Keeper 系統、批次處理、多參數函數

## 模式描述

函數返回或處理陣列時，陣列長度與實際有效數據不匹配，導致處理空值或越界。

## 漏洞特徵

```solidity
// ❌ 錯誤：分配過大陣列，未調整實際長度
function checkUpkeep() external view returns (bool, bytes memory) {
    // 分配最大可能大小
    uint256[] memory ids = new uint256[](maxSize * 10);
    address[] memory assets = new address[](maxSize * 10);
    
    uint256 index = 0;
    for (uint256 i = 0; i < maxSize; i++) {
        if (needsProcessing(i)) {
            ids[index] = i;
            assets[index] = getAsset(i);
            index++;
        }
    }
    
    // ❌ 返回完整陣列，包含大量空值
    return (index > 0, abi.encode(ids, assets));
}

function performUpkeep(bytes calldata data) external {
    (uint256[] memory ids, address[] memory assets) = 
        abi.decode(data, (uint256[], address[]));
    
    // ❌ 遍歷全部，包含空值
    for (uint256 i = 0; i < ids.length; i++) {
        // assets[i] 可能是 address(0)
        processAsset(assets[i]);  // 可能 revert
    }
}

// ✅ 正確：調整陣列長度後返回
function checkUpkeep() external view returns (bool, bytes memory) {
    uint256[] memory ids = new uint256[](maxSize * 10);
    address[] memory assets = new address[](maxSize * 10);
    
    uint256 index = 0;
    for (uint256 i = 0; i < maxSize; i++) {
        if (needsProcessing(i)) {
            ids[index] = i;
            assets[index] = getAsset(i);
            index++;
        }
    }
    
    // ✅ 調整陣列長度
    assembly {
        mstore(ids, index)
        mstore(assets, index)
    }
    
    return (index > 0, abi.encode(ids, assets));
}
```

## 真實案例

### Zaros (2025-01 CodeHawks)

**檔案**: `FeeConversionKeeper.sol`

```solidity
function checkUpkeep(bytes calldata)
    external
    view
    returns (bool upkeepNeeded, bytes memory performData)
{
    uint256[] memory liveMarketIds = LiveMarkets.load().getMarketIds();
    
    // ❌ 分配 10 倍大小的陣列
    uint128[] memory marketIds = new uint128[](liveMarketIds.length * 10);
    address[] memory assets = new address[](liveMarketIds.length * 10);
    
    uint256 index;
    for (uint256 i; i < liveMarketIds.length; i++) {
        // ... 填充部分元素 ...
        index++;
    }
    
    if (upkeepNeeded) {
        // ❌ 沒有調整長度，返回包含空值的陣列
        performData = abi.encode(marketIds, assets);
    }
}

function performUpkeep(bytes calldata performData) external {
    (uint128[] memory marketIds, address[] memory assets) = 
        abi.decode(performData, (uint128[], address[]));
    
    for (uint256 i; i < marketIds.length; i++) {
        // ❌ assets[i] 可能是 address(0)
        // → revert Errors.CollateralDisabled(address(0))
        convertFees(marketIds[i], assets[i]);
    }
}
```

**修復**:
```solidity
if (upkeepNeeded) {
    // ✅ 調整陣列長度
    assembly {
        mstore(marketIds, index)
        mstore(assets, index)
    }
    performData = abi.encode(marketIds, assets);
}
```

## 常見變體

### 1. 返回長度 + 陣列
```solidity
// 返回有效長度
return abi.encode(validCount, array);

// 使用時
(uint256 count, uint256[] memory arr) = abi.decode(data, (...));
for (uint256 i = 0; i < count; i++) {  // 用 count 而非 arr.length
    process(arr[i]);
}
```

### 2. 使用動態陣列
```solidity
// 使用 push 動態添加
uint256[] memory temp = new uint256[](maxSize);
uint256 count;
for (...) {
    temp[count++] = value;
}

// 複製到正確大小的陣列
uint256[] memory result = new uint256[](count);
for (uint256 i = 0; i < count; i++) {
    result[i] = temp[i];
}
```

### 3. Assembly 調整長度
```solidity
assembly {
    mstore(array, actualLength)  // 修改長度槽
}
```

## 檢測方法

### 1. 搜索動態陣列分配

```bash
grep -rn "new.*\[\]" contracts/ | grep -v "length"
```

### 2. 檢查 ABI encode/decode

```bash
grep -rn "abi.encode\|abi.decode" contracts/
```

確認陣列長度是否正確處理。

## 標籤
`array` `data-structure` `keeper` `medium-severity`
