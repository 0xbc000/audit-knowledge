# Assembly / Low-Level Parsing Vulnerability Patterns

## Overview

手寫 assembly 解析 bytes 是高風險操作。
常見於：跨鏈橋、簽名驗證、calldata 解碼。

---

## Pattern 1: Missing Bytes Length Prefix (32-byte offset)

### Description
Solidity `bytes` 在記憶體中的佈局：前 32 bytes 是長度，之後才是實際數據。
很多開發者忘記加這個 offset。

### Vulnerable Code
```solidity
function parseData(bytes memory data) internal {
    address target;
    assembly {
        // ❌ WRONG: 直接從 data 讀取，讀到的是長度！
        target := mload(add(data, 20))
    }
}
```

### Correct Code
```solidity
function parseData(bytes memory data) internal {
    address target;
    assembly {
        // ✅ CORRECT: 跳過 32-byte 長度前綴
        target := mload(add(data, 52))  // 32 + 20
        // 或者
        target := mload(add(add(data, 0x20), 20))
    }
}
```

### Detection
```
在 assembly 中搜索：
- mload(add(data, X)) 其中 X < 32
- 沒有 add(data, 0x20) 或 add(data, 32)
```

### Real Case: Olas VerifyBridgedData
```solidity
// 漏洞代碼
assembly {
    i := add(i, 20)
    target := mload(add(data, i))  // ❌ 沒加 32-byte offset
}
```

---

## Pattern 2: Unmasked mload for Sub-Word Types

### Description
`mload` 總是讀取 32 bytes。如果目標類型小於 32 bytes（如 address=20, uint96=12），需要 mask 或 shift。

### Vulnerable Code
```solidity
function parseAddress(bytes memory data) internal returns (address target) {
    assembly {
        // ❌ WRONG: mload 讀 32 bytes，高位有垃圾數據
        target := mload(add(data, 32))
    }
}
```

### Correct Code
```solidity
function parseAddress(bytes memory data) internal returns (address target) {
    assembly {
        // ✅ CORRECT: 用 and() mask 掉高位
        target := and(mload(add(data, 32)), 0xffffffffffffffffffffffffffffffffffffffff)
        
        // 或者用 shr() 右移
        // target := shr(96, mload(add(data, 32)))
    }
}
```

### Common Masks
```solidity
// address (20 bytes)
and(x, 0xffffffffffffffffffffffffffffffffffffffff)

// uint96 (12 bytes)
and(x, 0xffffffffffffffffffffffff)

// uint32 (4 bytes)
and(x, 0xffffffff)

// bytes4 (4 bytes)
and(x, 0xffffffff00000000000000000000000000000000000000000000000000000000)
```

---

## Pattern 3: Inconsistent Offset Tracking

### Description
在迴圈中手動追蹤 offset，但 assembly 和 Solidity 高階代碼混用時容易出錯。

### Vulnerable Code
```solidity
function processMultiple(bytes memory data) internal {
    uint256 i = 0;
    while (i < data.length) {
        address target;
        uint256 value;
        
        assembly {
            i := add(i, 20)  // ❌ assembly 修改 i
            target := mload(add(data, i))
            i := add(i, 12)
            value := mload(add(data, i))
        }
        
        // ❌ 這裡的 i 和 assembly 裡的不同步
        bytes memory payload = new bytes(data.length - i);
    }
}
```

### Correct Code
```solidity
function processMultiple(bytes memory data) internal {
    uint256 offset = 32; // 從長度後開始
    
    while (offset < data.length + 32) {
        address target;
        uint256 value;
        
        assembly {
            target := and(mload(add(data, offset)), 0xffffffffffffffffffffffffffffffffffffffff)
        }
        offset += 20;
        
        assembly {
            value := mload(add(data, offset))
        }
        offset += 32;
        
        // offset 在高階代碼中一致追蹤
    }
}
```

---

## Pattern 4: Missing Bounds Check

### Description
從 bytes 解析時沒檢查是否越界。

### Vulnerable Code
```solidity
function parse(bytes memory data) internal {
    uint32 payloadLength;
    assembly {
        payloadLength := mload(add(data, 36))  // 讀取 payload 長度
    }
    
    // ❌ 沒檢查 payloadLength 是否超出 data.length
    bytes memory payload = new bytes(payloadLength);
    for (uint256 j = 0; j < payloadLength; ++j) {
        payload[j] = data[40 + j];  // 可能越界
    }
}
```

### Correct Code
```solidity
function parse(bytes memory data) internal {
    require(data.length >= 40, "Data too short");
    
    uint32 payloadLength;
    assembly {
        payloadLength := and(mload(add(data, 36)), 0xffffffff)
    }
    
    // ✅ 檢查 payload 不會越界
    require(data.length >= 40 + payloadLength, "Payload exceeds data");
    
    bytes memory payload = new bytes(payloadLength);
    // ...
}
```

---

## Pattern 5: Self-Call via Parsed Target

### Description
解析出的 `target` 地址可以是合約自身，繞過 `msg.sender` 檢查。

### Vulnerable Code
```solidity
function processMessage(bytes memory data) external {
    address target;
    bytes memory payload;
    // ... parse target and payload from data
    
    // ❌ target 可以是 address(this)
    (bool success,) = target.call(payload);
}

function changeAdmin(address newAdmin) external {
    // 這個檢查可被繞過！
    require(msg.sender == address(this), "Self call only");
    admin = newAdmin;
}
```

### Attack
```
1. 構造 data，使 target = address(this)
2. payload = abi.encodeCall(changeAdmin, attackerAddress)
3. 調用 processMessage(data)
4. 合約自己調用自己，msg.sender == address(this) 通過
5. Admin 被改成攻擊者
```

### Fix
```solidity
function processMessage(bytes memory data) external {
    address target;
    // ... parse
    
    // ✅ 禁止自調用
    require(target != address(this), "No self call");
    
    (bool success,) = target.call(payload);
}
```

---

## Quick Reference

| 漏洞 | 檢測關鍵字 | 修復 |
|------|-----------|------|
| 缺少 32-byte offset | `mload(add(data, X))` X<32 | 加 `add(data, 0x20)` |
| 未 mask | `target := mload(...)` | 加 `and(..., mask)` |
| Offset 不同步 | assembly 修改 i/offset | 統一在高階代碼追蹤 |
| 無邊界檢查 | 無 `require(length)` | 加 bounds check |
| Self-call | `target.call(payload)` | 禁止 `target == this` |

## Related
- `cross-chain/` - 跨鏈消息解析
- `access-control/` - Self-call 繞過
