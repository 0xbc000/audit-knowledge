# Chainlink Phase ID 處理錯誤 (Chainlink Phase ID Handling)

## 風險等級
**Medium / High** - 可能導致 Oracle DoS 或返回錯誤價格

## 描述

Chainlink 的 `roundId` 是一個複合數值，包含 `phaseId` 和 `aggregatorRoundId`。當 Chainlink 升級聚合器時，`phaseId` 會遞增，導致 `roundId` 跳躍 2^64。如果協議沒有正確處理這種情況，可能導致歷史價格查詢失敗。

## 技術背景

```solidity
// Chainlink roundId 結構
// roundId = (phaseId << 64) | aggregatorRoundId

// 例如:
// Phase 1, Round 100: roundId = (1 << 64) | 100 = 18446744073709551716
// Phase 2, Round 1:   roundId = (2 << 64) | 1   = 36893488147419103233

// 差距: ~18446744073709551517 (約 2^64)
```

## 漏洞模式

```solidity
// ❌ Beanstalk - LibChainlinkOracle.sol
function getEthUsdTwap(uint256 lookback) internal view returns (uint256 price) {
    (uint80 roundId, int256 answer, , uint256 timestamp, ) = 
        priceAggregator.latestRoundData();
    
    // 往前遍歷計算 TWAP
    while (timestamp > endTimestamp) {
        roundId -= 1;  // ❌ 簡單減 1，沒考慮 phase 變化
        
        try priceAggregator.getRoundData(roundId) returns (...) {
            // 如果 phase 剛變化，roundId-1 會指向不存在的 round
            // → revert
        } catch {
            return 0;
        }
    }
}
```

## 攻擊場景

### 場景 1: TWAP 計算 DoS
```
1. Chainlink 在 T 時刻升級聚合器（phase 從 5 → 6）
2. 用戶調用需要 TWAP 的函數
3. 函數嘗試查詢 roundId - 1
4. 該 round 在 phase 5，但 phase 5 已不再活躍
5. 查詢失敗 → 函數 revert
6. 協議功能受阻最長可達 24 小時
```

### 場景 2: 錯誤價格
```
1. Phase 變化後，協議可能錯誤地使用 minPrice
2. 因為找不到有效的歷史數據
3. 影響清算、鑄造等關鍵操作
```

## 影響

1. **DoS** - Oracle 相關功能暫時無法使用
2. **錯誤價格** - 使用 fallback 價格可能不準確
3. **套利機會** - 攻擊者可預測 phase 變化時機

## 檢測方法

### 1. 找歷史數據查詢
```bash
grep -rn "getRoundData\|roundId.*-" contracts/ --include="*.sol"
```

### 2. 檢查 roundId 處理
```solidity
// 可疑模式
roundId -= 1;           // ❌ 沒考慮 phase
roundId = roundId - 1;  // ❌ 同上

// 應該檢查
(uint16 phaseId, uint64 aggRoundId) = parseIds(roundId);
```

## 修復方式

### 方案 1: 正確解析 roundId
```solidity
function parseIds(uint80 roundId) internal pure returns (uint16, uint64) {
    return (uint16(roundId >> 64), uint64(roundId));
}

function getHistoricalRound(uint80 currentRoundId) internal view returns (...) {
    (uint16 phaseId, uint64 aggRoundId) = parseIds(currentRoundId);
    
    if (aggRoundId > 1) {
        // 同一 phase 內往回查
        return priceAggregator.getRoundData(currentRoundId - 1);
    } else {
        // 需要查前一個 phase 的最後一個 round
        // 這需要額外的 phaseAggregators 查詢
        return getPreviousPhaseLastRound(phaseId - 1);
    }
}
```

### 方案 2: 使用 try-catch 並處理失敗
```solidity
function getTwapSafe(uint256 lookback) internal view returns (uint256) {
    // 嘗試獲取 TWAP
    try this.getEthUsdTwap(lookback) returns (uint256 price) {
        return price;
    } catch {
        // Fallback: 使用單點價格
        return getEthUsdPrice();
    }
}
```

### 方案 3: 限制 lookback 範圍
```solidity
// 只查詢最近幾個 round，降低跨 phase 風險
uint256 constant MAX_ROUNDS_LOOKBACK = 10;
```

## 真實案例

| 專案 | 位置 | 問題 | 影響 |
|------|------|------|------|
| Beanstalk 2024 | LibChainlinkOracle | roundId 簡單減 1 | TWAP DoS |
| Blueberry | PriceOracle | 同樣問題 | Medium |
| Iron Bank | Oracle | 同樣問題 | Medium |

## 相關模式
- [oracle-staleness.md](./oracle-staleness.md)
- [chainlink-min-max-answer.md](./chainlink-min-max-answer.md) (待新增)

## 標籤
`oracle` `chainlink` `phase-id` `dos` `medium-severity`
