# Oracle 價格過期未檢查 (Oracle Staleness)

## 類別
- **類型**: Oracle 漏洞
- **嚴重性**: High / Critical
- **常見於**: Lending, DEX, 清算系統

## 模式描述

協議從 Oracle 取得價格時，未檢查價格的更新時間，導致使用過期（stale）價格進行關鍵計算。

## 漏洞特徵

```solidity
// ❌ 錯誤模式：取得 timestamp 但不使用
function getPrice() public view returns (uint256) {
    (uint256 price, uint256 lastUpdate) = oracle.getLatestPrice();
    if (price == 0) revert InvalidPrice();
    return price;  // lastUpdate 被忽略
}

// ❌ 錯誤模式：完全不取 timestamp
function getPrice() public view returns (uint256) {
    return oracle.getLatestPrice();
}

// ✅ 正確模式
function getPrice() public view returns (uint256) {
    (uint256 price, uint256 lastUpdate) = oracle.getLatestPrice();
    if (price == 0) revert InvalidPrice();
    if (block.timestamp - lastUpdate > MAX_STALENESS) revert StalePrice();
    return price;
}
```

## 真實案例

### RAAC (2025-02 CodeHawks)

**檔案**: `LendingPool.sol` → `getNFTPrice`

```solidity
/**
 * @notice Gets the current price of an NFT from the oracle
 * Checks if the price is stale  // ⚠️ 註釋說會檢查，但實際沒有
 */
function getNFTPrice(uint256 tokenId) public view returns (uint256) {
    (uint256 price, uint256 lastUpdateTimestamp) = priceOracle.getLatestPrice(tokenId);
    if (price == 0) revert InvalidNFTPrice();
    return price;  // ❌ lastUpdateTimestamp 完全沒用到
}
```

**影響**:
- 使用過期價格可能導致：
  - 允許不該通過的借貸（collateral 被高估）
  - 錯誤觸發清算（collateral 被低估）
  - 套利攻擊

### Chainlink 標準檢查

```solidity
function getChainlinkPrice() public view returns (uint256) {
    (
        uint80 roundId,
        int256 price,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    ) = priceFeed.latestRoundData();
    
    // ✅ 完整的檢查
    require(price > 0, "Invalid price");
    require(updatedAt > 0, "Round not complete");
    require(block.timestamp - updatedAt <= MAX_STALENESS, "Stale price");
    require(answeredInRound >= roundId, "Stale round");
    
    return uint256(price);
}
```

## 檢測方法

### 1. 靜態分析關鍵字
```bash
grep -rn "latestPrice\|latestRoundData\|getPrice" contracts/ --include="*.sol"
```

找到後檢查：
- 是否有取 timestamp/updatedAt
- 是否有與 block.timestamp 比較

### 2. 自動化檢查

```solidity
// Invariant test
function invariant_priceNotStale() public {
    (uint256 price, uint256 lastUpdate) = oracle.getLatestPrice();
    
    // 假設最大允許 1 小時過期
    assert(block.timestamp - lastUpdate <= 1 hours);
}
```

### 3. Prompt Template

```markdown
## Oracle 使用分析

函數從 oracle 取得價格：
[貼上程式碼]

## 檢查
1. 是否取得了價格更新時間？
2. 是否檢查價格是否過期？
3. 過期閾值是否合理？
4. 如果價格過期會發生什麼？
```

## 變體

### 1. Chainlink 特有
```solidity
// 還要檢查 round 是否完成
require(answeredInRound >= roundId, "Stale round");
```

### 2. L2 特有
```solidity
// L2 需要檢查 sequencer 是否在線
(, int256 answer, uint256 startedAt, , ) = sequencerUptimeFeed.latestRoundData();
bool isSequencerUp = answer == 0;
if (!isSequencerUp) revert SequencerDown();
```

### 3. 自定義 Oracle
```solidity
// 自定義 oracle 可能有不同的 API
uint256 lastUpdate = oracle.lastUpdateTimestamp();
require(block.timestamp - lastUpdate <= MAX_STALENESS);
```

## 預防措施

1. **建立統一的 Oracle 包裝器**
```solidity
library OracleLib {
    function getSafePrice(
        AggregatorV3Interface feed,
        uint256 maxStaleness
    ) internal view returns (uint256) {
        // 所有檢查集中在這裡
    }
}
```

2. **設定合理的過期閾值**
   - 高流動性資產（ETH/USD）: 1 小時
   - 中等流動性: 4-6 小時
   - 低流動性/RWA: 24 小時或更長

3. **監控和警報**
   - 監控 oracle 更新頻率
   - 價格偏差警報

## 相關漏洞
- [Oracle Manipulation](./oracle-manipulation.md)
- [Price Deviation](./price-deviation.md)

## 標籤
`oracle` `staleness` `chainlink` `high-severity` `lending`
