# Chainlink Oracle Security Checklist

> Source: [Cyfrin - Chainlink Oracle DeFi Attacks](https://medium.com/cyfrin/chainlink-oracle-defi-attacks-93b6cb6541bf)
> Author: @devdacian (Aug 2023)

## Overview

Chainlink 是最常用的 Oracle 解決方案，但整合時有許多常見漏洞。本文檔整理了 13 個關鍵安全考量。

---

## 1. Not Checking For Stale Prices ⭐ 最常見

**問題：** 未檢查 `latestRoundData()` 返回的價格是否過期。

**錯誤代碼：**
```solidity
// ❌ 沒有檢查價格是否過期
(, int256 price, , , ) = priceFeed.latestRoundData();
```

**正確代碼：**
```solidity
// ✅ 檢查 updatedAt 是否在心跳間隔內
(, int256 price, , uint256 updatedAt, ) = priceFeed.latestRoundData();
if (updatedAt < block.timestamp - 60 * 60 /* 1 hour */) {
    revert("stale price feed");
}
```

**關鍵：** staleness threshold 應該對應該 feed 的 heartbeat（可在 [Chainlink Docs](https://docs.chain.link/data-feeds/price-feeds/addresses) 查詢）。

**案例：** 19+ 個審計案例，包括 Sherlock USSD、Code4rena Juicebox 等。

---

## 2. Not Checking For Down L2 Sequencer ⭐ L2 必查

**問題：** 在 Arbitrum/Optimism 等 L2 上，Sequencer 宕機時價格可能看起來是新的但實際已過期。

**解決：** 必須檢查 L2 Sequencer 狀態。

```solidity
// 需要額外呼叫 Sequencer Uptime Feed
// 參考: https://docs.chain.link/data-feeds/l2-sequencer-feeds
```

**適用鏈：** Arbitrum, Optimism, Base, 其他 L2

---

## 3. Same Heartbeat Used For Multiple Price Feeds

**問題：** 不同 price feed 有不同的 heartbeat，不能用同一個 staleness threshold。

**錯誤代碼：**
```solidity
// ❌ 兩個 feed 用同一個 heartbeatInterval
require(block.timestamp - updatedAt <= heartbeatInterval);
require(block.timestamp - USDCUpdatedAt <= heartbeatInterval);
```

**例子：**
- ETH/USD heartbeat: 1 hour
- USDC/USD heartbeat: 24 hours

**解決：** 每個 feed 用各自的 heartbeat threshold。

---

## 4. Oracle Price Feeds Not Updated Frequently

**問題：** 選擇了更新頻率低的 feed，導致價格偏差大。

**關鍵指標：**
- Heartbeat: 更新間隔上限
- Deviation Threshold: 價格變動多少才觸發更新

**建議：** 選擇 heartbeat 最短、deviation threshold 最低的 feed。

---

## 5. VRF Request Confirmation (Chain Reorg)

**問題：** `REQUEST_CONFIRMATIONS` 設太低，在有頻繁 reorg 的鏈上會導致隨機數改變。

**錯誤：**
```solidity
// ❌ 預設值 3，但 Polygon 每天有 5+ 次深度 > 3 的 reorg
uint16 internal constant REQUEST_CONFIRMATIONS = 3;
```

**解決：** 根據目標鏈的 reorg 深度設定適當值。
- Ethereum: 3 通常足夠
- Polygon: 建議 > 30

---

## 6. Assuming Oracle Price Precision ⭐ 常見

**問題：** 假設所有 feed 都是 8 或 18 decimals。

**實際情況：**
- 非 ETH pairs (如 BTC/USD): 通常 8 decimals
- ETH pairs (如 TOKEN/ETH): 通常 18 decimals
- 例外: AMPL/USD 是 18 decimals

**解決：**
```solidity
uint8 decimals = AggregatorV3Interface(priceFeed).decimals();
```

---

## 7. Incorrect Oracle Price Feed Address

**問題：** 硬編碼了錯誤的 feed 地址。

**案例：** USSD 審計中，註釋寫 BTC/USD 但實際地址是 ETH/USD。

**審計方法：** 手動驗證每個地址對應的是正確的 feed。

---

## 8. Oracle Price Updates Can Be Front-Run

**問題：** 攻擊者可以三明治攻擊 Oracle 更新。

**攻擊流程：**
1. 監控 mempool 中的 Oracle 更新交易
2. 在更新前 mint/deposit
3. 在更新後 burn/withdraw

**緩解方案：**
- 加入 mint/burn 手續費
- 強制 deposit 後有 delay 才能 withdraw

**延伸閱讀：** Angle Research Series, Synthetix Frontrunning History

---

## 9. Unhandled Oracle Revert Denial Of Service

**問題：** Oracle 呼叫 revert 會導致整個協議 DoS。

**風險：** Chainlink multisig 可以隨時封鎖 feed 存取。

**解決方案：**
```solidity
// 用 try/catch 包裝
try priceFeed.latestRoundData() returns (...) {
    // 正常邏輯
} catch {
    // 使用備用方案或 revert 友善訊息
}
```

- 提供更換/更新 feed 的功能
- 考慮備用 Oracle（如 Uniswap TWAP）

---

## 10. Unhandled Depeg Of Bridged Assets ⭐ 重要

**問題：** 用 BTC/USD 來定價 WBTC，但 WBTC 可能因橋被攻擊而脫鉤。

**攻擊流程：**
1. WBTC 橋被攻擊，WBTC 脫鉤
2. 攻擊者低價買入 WBTC
3. 存入協議，用 BTC 價格借款
4. 協議被掏空

**解決：** 使用 WBTC/BTC feed 監控脫鉤事件。

---

## 11. Oracle Returns Incorrect Price During Flash Crashes ⭐ 關鍵

**問題：** Chainlink feed 有 minAnswer/maxAnswer 限制，極端情況下會返回錯誤價格。

**攻擊場景：**
1. 資產閃崩，價格跌破 minAnswer
2. Oracle 繼續返回 minAnswer（而非真實更低價格）
3. 攻擊者低價買入，高價存入協議借款

**真實案例：** Venus/Blizz rekt (LUNA 崩盤時)

**解決：**
```solidity
require(price > minAnswer && price < maxAnswer, "price out of bounds");
```

**如何找 minAnswer/maxAnswer：**
1. 從 Chainlink 查 feed 地址
2. 讀取 aggregator 地址
3. 從 aggregator 讀取 minAnswer/maxAnswer

---

## 12. Placing Bets After Randomness Request (VRF)

**問題：** 請求隨機數後仍允許下注/購買。

**攻擊：** Front-run 隨機數回傳，用中獎號碼購買彩票。

**解決：** 請求隨機數後鎖定所有輸入。

---

## 13. Re-requesting Randomness (VRF)

**問題：** 允許重新請求隨機數。

**風險：** VRF provider 可以選擇性地只在結果有利時回傳。

**解決：** 不要允許重新請求，一次請求一個結果。

---

## 審計 Checklist

| # | 檢查項目 | 嚴重性 |
|---|---------|--------|
| 1 | 是否檢查 `updatedAt` staleness? | High |
| 2 | L2 是否檢查 Sequencer 狀態? | High |
| 3 | 多個 feed 是否用各自的 heartbeat? | Medium |
| 4 | 是否選擇了最佳 heartbeat/deviation 的 feed? | Medium |
| 5 | VRF REQUEST_CONFIRMATIONS 是否適合目標鏈? | Medium |
| 6 | 是否正確處理 decimals? | High |
| 7 | Feed 地址是否正確? | Critical |
| 8 | 是否有 front-run 保護? | Medium |
| 9 | Oracle revert 是否有處理? | Medium |
| 10 | Bridged asset 脫鉤是否有處理? | High |
| 11 | minAnswer/maxAnswer 是否有檢查? | High |
| 12 | VRF 請求後是否鎖定輸入? | High |
| 13 | VRF 是否禁止重新請求? | Medium |

---

## 參考資源

- [Chainlink Price Feeds](https://docs.chain.link/data-feeds/price-feeds/addresses)
- [L2 Sequencer Feeds](https://docs.chain.link/data-feeds/l2-sequencer-feeds)
- [Chainlink VRF Security](https://docs.chain.link/vrf/v2/security)
- [Angle Research Series](https://blog.angle.money/angle-research-series-part-1-oracles-and-front-running-d75184abc67)
- [Synthetix Frontrunning History](https://blog.synthetix.io/frontrunning-synthetix-a-history/)
