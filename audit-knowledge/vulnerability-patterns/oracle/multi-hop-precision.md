# 多跳 Oracle 精度損失 (Multi-Hop Oracle Precision Loss)

## 風險等級
**Medium** - 可能導致價格偏差和套利

## 描述
當 Oracle 需要通過多個中間價格計算最終價格時（如 TOKEN→ETH→USD），每次乘除運算都會產生精度損失，累積後可能導致顯著的價格偏差。

## 漏洞模式

```solidity
// ❌ QuantAMM - MultiHopOracle.sol
function _getData() internal view override returns (int216 data, uint40 timestamp) {
    (data, timestamp) = oracles[0].oracle.getData();
    
    for (uint i = 1; i < oracleLength; ) {
        (int216 oracleRes, uint40 oracleTimestamp) = oracleConfig.oracle.getData();
        
        if (oracleConfig.invert) {
            data = (data * 10 ** 18) / oracleRes;  // ❌ 除法截斷
        } else {
            data = (data * oracleRes) / 10 ** 18;  // ❌ 除法截斷
        }
    }
}
```

## 精度損失分析

### 單跳誤差
```
實際價格: 1234.567890123456789 (18 dp)
除法結果: 1234.567890123456000 (損失 789)
誤差: ~0.00000000000006%
```

### 多跳累積
```
3 跳計算:
Hop 1: 誤差 ε₁
Hop 2: 誤差 ε₂ (可能放大 ε₁)
Hop 3: 誤差 ε₃ (可能放大 ε₁ + ε₂)

最壞情況: 誤差可累積到 0.001% ~ 0.01%
```

### 極端案例
```solidity
// 當 data 很大，oracleRes 很小時
data = 1e36;
oracleRes = 1e9;  // 很小的價格
result = (1e36 * 1e18) / 1e9 = 1e45  // 可能溢出！

// 當 data 很小，oracleRes 很大時
data = 1e9;
oracleRes = 1e27;
result = (1e9 * 1e18) / 1e27 = 1  // 幾乎全部精度損失
```

## 影響

1. **套利機會** - 攻擊者可利用鏈上/鏈下價格差異
2. **錯誤清算** - 價格偏差導致不該清算的被清算
3. **權重計算錯誤** - 在動態權重 AMM 中導致錯誤的權重調整
4. **累積偏差** - 長時間運行後偏差可能增長

## 檢測方法

### 1. 找多跳計算
```bash
grep -rn "\/.*oracle\|oracle.*\/" contracts/
```

### 2. 測試極端值
```solidity
function test_multiHop_extremeValues() public {
    // 測試極大和極小價格
    oracle1.setPrice(1e36);
    oracle2.setPrice(1);
    
    int256 result = multiHop.getData();
    // 檢查是否溢出或精度完全損失
}
```

### 3. 比較單跳 vs 多跳
```solidity
function test_multiHop_accuracy() public {
    // 設置 A→B, B→C, A→C 三個 Oracle
    // 比較 A→B→C 和直接 A→C
    // 差異應該在可接受範圍內
}
```

## 修復方式

### 方案 1: 使用更高精度中間計算
```solidity
function _getData() internal view returns (int216 data, uint40 timestamp) {
    // 使用 int512 或 PRBMath 進行中間計算
    int512 highPrecisionData = int512(firstOracleData) * 1e36;
    
    for (uint i = 1; i < oracleLength; i++) {
        if (oracleConfig.invert) {
            highPrecisionData = (highPrecisionData * 1e36) / oracleRes;
        } else {
            highPrecisionData = (highPrecisionData * oracleRes) / 1e36;
        }
    }
    
    data = int216(highPrecisionData / 1e18);
}
```

### 方案 2: 限制跳數
```solidity
require(oracles.length <= 3, "Too many hops");
```

### 方案 3: 偏差驗證
```solidity
// 與直接 Oracle（如果存在）比較
int256 directPrice = directOracle.getPrice();
int256 multiHopPrice = multiHopOracle.getPrice();
require(
    abs(directPrice - multiHopPrice) <= directPrice * MAX_DEVIATION / 10000,
    "Multi-hop deviation too high"
);
```

## 真實案例

| 專案 | 位置 | 跳數 | 影響 |
|------|------|------|------|
| QuantAMM 2024 | MultiHopOracle.sol | 無限制 | 精度損失 |

## 相關模式
- [oracle-staleness.md](./oracle-staleness.md)
- [precision-loss.md](../math/precision-loss.md) (待新增)

## 標籤
`oracle` `precision` `multi-hop` `medium-severity`
