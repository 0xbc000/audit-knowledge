# TWAP Implementation Errors

> 自建 TWAP Oracle 的常見數學錯誤

## Overview

許多協議選擇自建 TWAP (Time-Weighted Average Price) 而不是使用 Chainlink。這帶來了一系列容易犯的數學錯誤。

**關鍵問題：** 開發者通常理解 TWAP 的概念，但在實現時犯下代數錯誤，導致 TWAP 保護完全失效。

---

## 1. Cumulative Price Cancellation ⭐ Critical

**問題：** 計算 TWAP 時，歷史累積價格被數學上消除，導致 TWAP 永遠等於當前現貨價格。

### 錯誤代碼

```solidity
// ❌ 致命錯誤：cumulativePriceLast 被消除
function validatePrice(uint256 slippage) external view returns (bool) {
    uint256 cumulativePriceLast = pair.price0CumulativeLast();
    uint256 elapsedTime = block.timestamp - blockTimestampLast;
    uint256 tradePrice = getPrice(); // 現貨價格
    
    // 錯誤計算
    uint256 cumulativePrice = cumulativePriceLast + (tradePrice * elapsedTime);
    uint256 timeWeightedAverage = (cumulativePrice - cumulativePriceLast) / elapsedTime;
    
    // derivation 永遠 = 0！
    uint256 derivation = abs(tradePrice - timeWeightedAverage);
    return derivation <= slippage;
}
```

### 數學證明

```
設：
  C = cumulativePriceLast（歷史累積）
  P = tradePrice（當前現貨）
  T = elapsedTime

計算過程：
  cumulativePrice = C + (P × T)
  TWAP = (cumulativePrice - C) / T
       = ((C + P×T) - C) / T
       = (P × T) / T
       = P

結論：TWAP ≡ 現貨價格（歷史數據被完全消除）
```

### 正確代碼

```solidity
// ✅ 正確：存儲上次的累積價格和時間戳
uint256 public storedCumulativePrice;
uint256 public storedTimestamp;

function updateOracle() external {
    storedCumulativePrice = pair.price0CumulativeLast();
    storedTimestamp = block.timestamp;
}

function validatePrice(uint256 slippage) external view returns (bool) {
    uint256 currentCumulative = pair.price0CumulativeLast();
    uint256 twap = (currentCumulative - storedCumulativePrice) / 
                   (block.timestamp - storedTimestamp);
    
    uint256 spotPrice = getPrice();
    uint256 deviation = abs(twap - spotPrice) * 1e18 / twap;
    return deviation <= slippage;
}
```

### 影響
- **TWAP 保護完全失效** — derivation 永遠為 0
- **Flash Loan 攻擊變得 trivial** — 操縱現貨價格後立即通過驗證
- **所有依賴此 Oracle 的操作都可被操縱**

### 真實案例
- **Autonolas/OLAS Tokenomics (2026)** — UniswapPriceOracle.sol 存在此漏洞
  - 被 V12 scanner 發現但標記為 Qa（嚴重低估）
  - 正確嚴重性：Critical

### 檢測方法

1. **代數分析**：
   ```
   找到 TWAP 計算公式
   手動展開並簡化
   檢查歷史數據是否在簡化後消失
   ```

2. **Foundry PoC**：
   ```solidity
   // 設置不同的 cumulativePriceLast 值
   // 驗證 TWAP 是否總是等於 spotPrice
   assertEq(computedTwap, spotPrice); // 如果通過 = 有漏洞
   ```

---

## 2. UQ112.112 vs 1e18 Unit Mismatch ⭐ High

**問題：** Uniswap V2 的累積價格使用 UQ112.112 定點格式，但協議用 1e18 格式處理。

### 背景知識

Uniswap V2 累積價格格式：
- **UQ112.112**：224 位定點數
- 112 位整數部分 + 112 位小數部分
- 值範圍：極大（~10³³ 到 10⁵⁰）

協議常用格式：
- **1e18**：標準 18 位小數
- 值範圍：較小（~10¹⁸ 到 10²⁵）

### 錯誤代碼

```solidity
// ❌ 混用不同格式
uint256 cumulativePriceLast = pair.price0CumulativeLast(); // UQ112.112
uint256 tradePrice = getPrice(); // 1e18 格式

// 直接相加 = 垃圾結果
uint256 cumulativePrice = cumulativePriceLast + (tradePrice * elapsedTime);
```

### 正確代碼

```solidity
// ✅ 方案 1：轉換 UQ112.112 到 1e18
uint256 priceFrom112 = (cumulativePriceLast * 1e18) >> 112;

// ✅ 方案 2：全程使用 UQ112.112
uint256 priceTo112 = (tradePrice << 112) / 1e18;

// ✅ 方案 3：使用 Uniswap 官方 library
import "@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol";
(uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = 
    UniswapV2OracleLibrary.currentCumulativePrices(pair);
```

### 影響
- **計算結果無意義** — 加法結果在數學上毫無意義
- **可能 overflow** — UQ112.112 值極大
- **靜默失敗** — 不會 revert，只是結果錯誤

---

## 3. Incorrect Time Weighting ⭐ Medium

**問題：** 錯誤地計算時間權重，導致 TWAP 偏向最近或最早的價格。

### 錯誤代碼

```solidity
// ❌ 錯誤：用 averagePrice 擴展，不是實際價格
uint256 timeWeightedAverage = 
    (snapshot.cumulativePrice + (snapshot.averagePrice * elapsedTime)) /
    ((snapshot.cumulativePrice / snapshot.averagePrice) + elapsedTime);
```

### 問題分析

```
這個公式嘗試用 C/A 重建「總時間」，但：
1. 只有當 C = A × previousTime 時才成立
2. 整數除法 C/A 會丟失精度
3. update 邏輯是 C += A × T，所以 C/A ≠ 總時間

結果：這不是真正的 TWAP，是一個有偏差的加權平均
```

### 正確代碼

```solidity
// ✅ 標準 TWAP 實現
struct Observation {
    uint256 timestamp;
    uint256 cumulativePrice;
}

Observation[] public observations;

function getTwap(uint256 lookbackPeriod) public view returns (uint256) {
    require(observations.length >= 2, "Not enough data");
    
    Observation memory oldest = findObservationBefore(block.timestamp - lookbackPeriod);
    Observation memory newest = observations[observations.length - 1];
    
    return (newest.cumulativePrice - oldest.cumulativePrice) / 
           (newest.timestamp - oldest.timestamp);
}
```

---

## 4. Single Block TWAP ⭐ Medium

**問題：** TWAP 觀察窗口太短，無法防止閃電貸攻擊。

### 錯誤代碼

```solidity
// ❌ 窗口 = 1 個區塊，無法防閃電貸
function getTwap() public view returns (uint256) {
    return (currentCumulative - lastCumulative) / (block.timestamp - lastTimestamp);
}
// 如果 lastTimestamp = block.timestamp - 12 秒，窗口只有 1 個區塊
```

### 正確代碼

```solidity
// ✅ 至少 30 分鐘窗口
uint256 constant MIN_TWAP_PERIOD = 30 minutes;

function getTwap() public view returns (uint256) {
    require(block.timestamp - oldestTimestamp >= MIN_TWAP_PERIOD, "TWAP period too short");
    return (currentCumulative - oldestCumulative) / (block.timestamp - oldestTimestamp);
}
```

### 建議窗口

| 用途 | 最小窗口 | 推薦窗口 |
|------|---------|---------|
| 價格驗證 | 10 分鐘 | 30 分鐘 |
| 清算 | 30 分鐘 | 1 小時 |
| 治理投票 | 1 小時 | 24 小時 |

---

## 5. No Fallback on TWAP Failure ⭐ Medium

**問題：** TWAP 計算失敗時 fallback 到現貨價格，削弱保護。

### 錯誤代碼

```solidity
// ❌ 失敗時用現貨價格
function getPrice() public view returns (uint256) {
    try this.getTwap() returns (uint256 twap) {
        return twap;
    } catch {
        return getSpotPrice(); // 可被操縱！
    }
}
```

### 正確代碼

```solidity
// ✅ 失敗時 revert
function getPrice() public view returns (uint256) {
    uint256 twap = getTwap(); // 讓它 revert
    return twap;
}

// 或者使用備用 Oracle
function getPrice() public view returns (uint256) {
    try this.getTwap() returns (uint256 twap) {
        return twap;
    } catch {
        return chainlinkOracle.getPrice(); // 用可信 Oracle 作為 fallback
    }
}
```

---

## Checklist

審計 TWAP 實現時，檢查：

- [ ] **代數驗證**：手動簡化公式，歷史數據是否被消除？
- [ ] **單位一致**：是否混用 UQ112.112 和 1e18？
- [ ] **時間窗口**：TWAP 觀察期是否 >= 10 分鐘？
- [ ] **Fallback**：失敗時是否 fallback 到可操縱的現貨價格？
- [ ] **更新機制**：累積價格和時間戳是否正確存儲和更新？

---

## 相關模式

- [Chainlink Security Checklist](chainlink-security-checklist.md) — 使用 Chainlink 的安全考量
- [Flash Loan Patterns](../flash-loan/flash-loan-patterns.md) — 閃電貸攻擊向量

---

*Created: 2026-01-31 | Source: Autonolas audit findings*
