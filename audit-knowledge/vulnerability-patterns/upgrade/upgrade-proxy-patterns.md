# Upgrade/Proxy Vulnerability Patterns

> 來源：Three Sigma, OpenZeppelin, Code4rena 2021-2024
> 整理：5 個 Critical/High Severity 案例

## Overview

可升級合約引入了傳統不可變合約沒有的風險。理解這些漏洞模式對於安全部署至關重要。

---

## 1. Uninitialized Proxy/Implementation ⭐ 最常見

**真實案例：** Wormhole (2022) - $10M Bug Bounty, Parity (2017) - $150M 永久凍結

**問題：** Proxy 部署後沒有調用 `initialize()`，或直接在 implementation 上調用而非通過 proxy。

### UUPS 特殊風險
```solidity
// UUPS Implementation
contract MyContractV1 is UUPSUpgradeable {
    address public owner;
    
    function initialize(address _owner) public initializer {
        owner = _owner;
    }
    
    function _authorizeUpgrade(address) internal override onlyOwner {}
}

// ❌ 如果 proxy 未初始化，攻擊者可以：
// 1. 調用 initialize(attackerAddress)
// 2. 成為 owner
// 3. 調用 upgradeTo(maliciousImplementation)
// 4. 完全控制合約
```

### Wormhole 攻擊流程
1. 升級腳本 bug 導致 `initialized` 被重置
2. 白帽調用 `initialize()`，成為 guardian
3. 調用 `submitContractUpgrade()` 指向惡意合約
4. 惡意合約執行 `selfdestruct`
5. Proxy 被永久銷毀

### 防禦
```solidity
// ✅ 在 constructor 中禁用 implementation 的初始化
constructor() {
    _disableInitializers();
}

// ✅ 部署時原子初始化
bytes memory initData = abi.encodeCall(Contract.initialize, (owner));
new TransparentUpgradeableProxy(impl, admin, initData);
```

---

## 2. Re-initialization Bugs

**真實案例：** AllianceBlock (2024)

**問題：** 初始化函數可以被多次調用。

### 漏洞場景
```solidity
// V1
contract StakingV1 is Initializable {
    bool private _initialized;
    address public rewardToken;
    
    function initialize(address _rewardToken) public initializer {
        rewardToken = _rewardToken;
    }
}

// V2 升級時 bug 導致 _initialized 被重置為 false
contract StakingV2 is Initializable {
    // ❌ 存儲佈局改變導致 _initialized 被覆蓋
    address public newVariable;  // 這個佔用了 _initialized 的 slot！
    address public rewardToken;
    
    function initialize(address _rewardToken) public initializer {
        rewardToken = _rewardToken;
    }
}
```

### AllianceBlock 攻擊
1. 升級導致 `initialized` 被重置為 false
2. 攻擊者調用 `initialize()`
3. 重設 `rewardToken`, `stakingToken`, `rewardRate`
4. 設置無限獎勵率，提取大量代幣

### 防禦
```solidity
// ✅ 使用 reinitializer 進行版本控制
function initializeV2(address _newParam) public reinitializer(2) {
    newParam = _newParam;
}

// ✅ 每個版本都有獨立的初始化函數
function initializeV3() public reinitializer(3) {
    // ...
}
```

---

## 3. Storage Layout Collision ⭐ 隱蔽

**真實案例：** Audius (2022) - $6M 被盜

**問題：** 升級後的存儲佈局與原版本不一致。

### 漏洞範例
```solidity
// V1 Implementation
contract V1 {
    bool public initialized;    // slot 0
    address public owner;       // slot 1
}

// V2 Implementation - 插入新變量導致碰撞
contract V2 {
    address public proxyAdmin;  // slot 0 - 覆蓋了 initialized！
    bool public initialized;    // slot 1
    address public owner;       // slot 2
}
```

### Audius 攻擊流程
1. 升級時在 proxy 中添加 `proxyAdmin` 變量
2. `proxyAdmin` 佔用了 `initialized` 的 slot 0
3. 讀取 `initialized` 時得到 `proxyAdmin` 地址（非零）
4. 合約認為未初始化，允許重新初始化
5. 攻擊者成為 governor，轉走 $6M

### 防禦
```solidity
// ✅ 使用 storage gaps
contract V1 {
    bool public initialized;
    address public owner;
    
    // 預留 50 個 slot 給未來升級
    uint256[50] private __gap;
}

// ✅ 新版本從 gap 中取用
contract V2 {
    bool public initialized;
    address public owner;
    address public newVariable;  // 使用 __gap 的一個 slot
    
    uint256[49] private __gap;  // gap 減少 1
}
```

### 使用 OpenZeppelin Upgrades Plugin
```bash
# 自動檢測存儲碰撞
npx hardhat run scripts/upgrade.js --network mainnet
# 插件會比較 V1 和 V2 的存儲佈局
```

---

## 4. Unauthorized/Malicious Upgrades

**真實案例：** PAID Network (2021), Ankr (2022)

**問題：** 升級權限被竊取或濫用。

### 攻擊方式
1. **私鑰洩露/釣魚** - PAID Network
2. **Access Control 缺失** - 忘記 `onlyOwner`
3. **內部人員作惡** - Rug pull

### PAID Network 攻擊
1. 攻擊者獲得 proxy admin 私鑰
2. 部署惡意 implementation（可無限 mint）
3. 升級 proxy 指向惡意合約
4. Mint 大量代幣並賣出

### 防禦
```solidity
// ✅ 多簽控制升級
ProxyAdmin admin = new ProxyAdmin();
admin.transferOwnership(GNOSIS_SAFE_ADDRESS);

// ✅ Timelock 延遲升級
TimelockController timelock = new TimelockController(
    2 days,  // 最小延遲
    proposers,
    executors
);
proxyAdmin.transferOwnership(address(timelock));

// ✅ UUPS 必須有 _authorizeUpgrade
function _authorizeUpgrade(address) internal override onlyOwner {
    // 可加入額外檢查
}
```

---

## 5. Dangerous selfdestruct/delegatecall

**真實案例：** Furucombo (2021) - $14M, Parity Wallet (2017)

**問題：** Implementation 中有 `selfdestruct` 或不受限的 `delegatecall`。

### selfdestruct 風險
```solidity
// ❌ 千萬不要在可升級合約中使用
contract BadImplementation {
    function destroy() external onlyOwner {
        selfdestruct(payable(owner));
    }
}

// 如果有人調用 destroy()：
// 1. Implementation 被銷毀
// 2. Proxy delegatecall 到空地址
// 3. 合約永久失效
```

### 不受限 delegatecall 風險
```solidity
// ❌ Furucombo 的錯誤
contract Handler {
    function execute(address target, bytes calldata data) external {
        // 允許任意 delegatecall！
        (bool success,) = target.delegatecall(data);
    }
}

// 攻擊者可以：
// 1. 傳入惡意合約地址
// 2. 在合約上下文中執行任意代碼
// 3. 修改存儲、轉移資金
```

### 防禦
```solidity
// ✅ 永遠不要在 implementation 中使用 selfdestruct
// ✅ 嚴格限制 delegatecall 目標
mapping(address => bool) public trustedHandlers;

function execute(address target, bytes calldata data) external {
    require(trustedHandlers[target], "Untrusted handler");
    (bool success,) = target.delegatecall(data);
}
```

---

## Proxy 類型安全比較

| 類型 | 升級函數位置 | 主要風險 |
|------|-------------|----------|
| Transparent | Proxy | Function selector collision |
| UUPS | Implementation | Implementation 未初始化 |
| Diamond | Facets | 複雜的存儲管理 |
| Beacon | Beacon | 單點故障 |

---

## 審計 Checklist

| # | 檢查項目 | 嚴重性 |
|---|---------|--------|
| 1 | Initialize 是否在部署時原子調用？ | Critical |
| 2 | Implementation 是否禁用初始化？ | Critical |
| 3 | 存儲佈局是否與前版本兼容？ | Critical |
| 4 | 升級權限是否用多簽/Timelock？ | High |
| 5 | 是否有 selfdestruct？ | Critical |
| 6 | 是否有不受限的 delegatecall？ | Critical |
| 7 | _authorizeUpgrade 是否有權限檢查？ | Critical |
| 8 | 是否使用 storage gaps？ | Medium |
| 9 | reinitializer 版本是否正確？ | High |

---

## 工具

### OpenZeppelin Upgrades Plugin
```javascript
// hardhat.config.js
require('@openzeppelin/hardhat-upgrades');

// 部署
const Box = await ethers.getContractFactory("Box");
const box = await upgrades.deployProxy(Box, [42]);

// 升級（自動檢查存儲兼容性）
const BoxV2 = await ethers.getContractFactory("BoxV2");
await upgrades.upgradeProxy(box.address, BoxV2);
```

### Slither 存儲分析
```bash
slither-check-upgradeability proxy.sol ProxyContract impl.sol ImplContract
```

---

## Minimal Reproduction (Pattern 1: Uninitialized UUPS Proxy)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract VulnerableImplV1 is Initializable, UUPSUpgradeable {
    address public owner;

    // ❌ Missing _disableInitializers() in constructor
    function initialize(address _owner) public initializer {
        owner = _owner;
    }

    function _authorizeUpgrade(address) internal override {
        require(msg.sender == owner, "not owner");
    }

    function version() external pure returns (uint256) { return 1; }
}

contract MaliciousImplV2 {
    function drain() external { selfdestruct(payable(msg.sender)); }
}
```

### Foundry Test Draft

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

// paste VulnerableImplV1 and MaliciousImplV2 above

contract UninitializedProxyTest is Test {
    function testAttackerTakesOverUninitializedImpl() public {
        VulnerableImplV1 impl = new VulnerableImplV1();
        // Implementation is NOT initialized — attacker calls initialize
        address attacker = makeAddr("attacker");
        vm.prank(attacker);
        impl.initialize(attacker);
        assertEq(impl.owner(), attacker, "attacker became owner");
    }
}
```

---

## 參考資源

- [OpenZeppelin Upgrades](https://docs.openzeppelin.com/upgrades-plugins/1.x/)
- [EIP-1967: Standard Proxy Storage Slots](https://eips.ethereum.org/EIPS/eip-1967)
- [Three Sigma: Upgradeable Contract Security](https://threesigma.xyz/blog/web3-security/upgradeable-contract-security-risks-vulnerabilities)
- [Trail of Bits: Contract Upgrade Anti-Patterns](https://blog.trailofbits.com/2018/09/05/contract-upgrade-anti-patterns/)
