# ERC4626 Vault Vulnerability Patterns

> 來源：Code4rena 2024 審計報告, OpenZeppelin 文檔
> 整理：5 個 High Severity 案例

## Overview

ERC4626 是標準化的 Vault 接口，但有幾個經典漏洞模式需要注意，尤其是 Inflation Attack。

---

## 1. First Depositor Inflation Attack ⭐ 最重要

**來源：** [Code4rena BakerFi H-39](https://github.com/code-423n4/2024-05-bakerfi-findings/issues/39), OpenZeppelin Docs

**問題：** 第一個存款者可以操縱 share/asset 匯率，讓後續存款者損失資金。

### 攻擊原理

**Share 計算公式：**
```
shares = (depositAmount * totalSupply) / totalAssets
```

**攻擊流程：**
1. 攻擊者存入 1 wei，獲得 1 share
2. 攻擊者直接轉入 100 ETH 到 Vault（donation）
3. 現在匯率變成：1 share = 100 ETH + 1 wei
4. 受害者存入 99 ETH
5. 受害者獲得：`99e18 * 1 / (100e18 + 1)` = 0 shares！
6. 受害者的 99 ETH 被攻擊者偷走

### 數學分析

設：
- `a₀` = 攻擊者初始存款
- `a₁` = 攻擊者 donation
- `u` = 用戶存款

用戶獲得的 shares：
```
shares = u × a₀ / (a₀ + a₁)
```

要讓用戶獲得 0 shares：
```
u < 1 + a₁/a₀
```

用 `a₀ = 1, a₁ = u` 就足夠 → 攻擊成本 ≈ 用戶存款

### 真實案例

**BakerFi (2024-05)：**
```solidity
function deposit(address receiver) public payable returns (uint256 shares) {
    // ❌ 沒有防護機制
    Rebase memory total = Rebase(_totalAssets(maxPriceAge), totalSupply());
    
    // 部署到策略
    uint256 amount = _strategy.deploy{value: msg.value}();
    
    // 計算 shares
    shares = total.toBase(amount, false);  // ❌ 向下取整
    _mint(receiver, shares);
}
```

攻擊者可以直接轉 aToken 到 Strategy，膨脹 `_totalAssets()`。

---

## 2. Virtual Offset 防禦機制

**來源：** [OpenZeppelin ERC4626](https://docs.openzeppelin.com/contracts/4.x/erc4626)

**OpenZeppelin 的解決方案：**

```solidity
// 使用虛擬 shares 和 assets
function _convertToShares(uint256 assets, Math.Rounding rounding) internal view returns (uint256) {
    return assets.mulDiv(
        totalSupply() + 10 ** _decimalsOffset(),  // 虛擬 shares
        totalAssets() + 1,                         // 虛擬 assets
        rounding
    );
}
```

**原理：**
1. `decimalsOffset` 提高 shares 精度（如 offset=3 則有 1000 虛擬 shares）
2. 虛擬 assets 捕獲部分 donation
3. 讓攻擊成本遠高於收益

**攻擊者損失分析：**
```
loss = a₁ / (1 + a₀)
```

即使 offset=0，攻擊者的損失也 ≥ 用戶存款。

---

## 3. Donation Attack via External Balance

**問題：** Vault 使用外部 balance 計算 totalAssets，可被 donation 操縱。

**漏洞代碼：**
```solidity
function totalAssets() public view returns (uint256) {
    // ❌ 使用外部 balance，可被 donation 操縱
    return token.balanceOf(address(this));
}
```

**安全代碼：**
```solidity
uint256 private _totalDeposited;

function totalAssets() public view returns (uint256) {
    // ✅ 使用內部追蹤的數量
    return _totalDeposited;
}

function deposit(uint256 assets, address receiver) public returns (uint256 shares) {
    // ...
    _totalDeposited += assets;
    // ...
}
```

---

## 4. Rounding Direction Inconsistency

**問題：** 不同操作的 rounding 方向不一致，導致套利機會。

**ERC4626 規範：**
| 操作 | 應該有利於 |
|------|-----------|
| deposit → shares | Vault (向下) |
| mint → assets | Vault (向上) |
| withdraw → shares | Vault (向上) |
| redeem → assets | Vault (向下) |

**漏洞範例：**
```solidity
// ❌ deposit 和 redeem 都向上取整，用戶可套利
function previewDeposit(uint256 assets) public view returns (uint256) {
    return assets.mulDiv(totalSupply(), totalAssets(), Math.Rounding.Up);
}

function previewRedeem(uint256 shares) public view returns (uint256) {
    return shares.mulDiv(totalAssets(), totalSupply(), Math.Rounding.Up);
}
```

**正確實現：**
```solidity
function previewDeposit(uint256 assets) public view returns (uint256) {
    return assets.mulDiv(totalSupply(), totalAssets(), Math.Rounding.Down);  // ✅
}

function previewRedeem(uint256 shares) public view returns (uint256) {
    return shares.mulDiv(totalAssets(), totalSupply(), Math.Rounding.Down);  // ✅
}
```

---

## 5. Preview Function Mismatch

**問題：** `preview*` 函數與實際操作結果不一致。

**ERC4626 要求：**
- `previewDeposit(assets)` 必須等於 `deposit(assets, receiver)` 返回的 shares
- 包括所有手續費

**漏洞範例：**
```solidity
function previewDeposit(uint256 assets) public view returns (uint256) {
    return _convertToShares(assets);  // ❌ 沒有計算手續費
}

function deposit(uint256 assets, address receiver) public returns (uint256 shares) {
    uint256 fee = assets * feeRate / 10000;
    shares = _convertToShares(assets - fee);  // 實際扣了手續費
    // ...
}
```

**正確實現：**
```solidity
function previewDeposit(uint256 assets) public view returns (uint256) {
    uint256 fee = _feeOnTotal(assets, _entryFeeBasisPoints());
    return _convertToShares(assets - fee);  // ✅ 包含手續費
}
```

---

## 防禦措施總結

### 1. 使用 OpenZeppelin 的 Virtual Offset
```solidity
import "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol";

contract MyVault is ERC4626 {
    constructor(IERC20 asset) ERC4626(asset) ERC20("MyVault", "mVLT") {
        // OpenZeppelin 預設 offset = 0，建議至少 3
    }
    
    function _decimalsOffset() internal pure override returns (uint8) {
        return 3;  // 1000 虛擬 shares
    }
}
```

### 2. 初始化時燒毀 Dead Shares
```solidity
constructor() {
    // 部署時立即存入並燒毀一些 shares
    _mint(address(0xdead), 1000);
}
```

### 3. 設定最小存款金額
```solidity
function deposit(uint256 assets, address receiver) public returns (uint256 shares) {
    require(assets >= MIN_DEPOSIT, "Deposit too small");
    // ...
}
```

### 4. 使用內部計數而非 balanceOf
```solidity
function totalAssets() public view override returns (uint256) {
    return _internalBalance;  // 不用 token.balanceOf(address(this))
}
```

---

## 審計 Checklist

| # | 檢查項目 | 嚴重性 |
|---|---------|--------|
| 1 | 是否有 Inflation Attack 防護？ | Critical |
| 2 | totalAssets 是否可被 donation 操縱？ | High |
| 3 | Rounding 方向是否正確且一致？ | High |
| 4 | preview* 函數是否與實際操作一致？ | High |
| 5 | 是否有最小存款限制？ | Medium |
| 6 | 第一筆存款是否有特殊處理？ | High |
| 7 | 手續費是否正確計入 preview？ | Medium |

---

## 參考資源

- [OpenZeppelin ERC4626 Docs](https://docs.openzeppelin.com/contracts/4.x/erc4626)
- [OpenZeppelin Defense Against Inflation Attack](https://blog.openzeppelin.com/a-novel-defense-against-erc4626-inflation-attacks)
- [MixBytes: Overview of Inflation Attack](https://mixbytes.io/blog/overview-of-the-inflation-attack)
- [YieldBox Implementation](https://github.com/boringcrypto/YieldBox)
