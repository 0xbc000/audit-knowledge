# ERC4626 maxDeposit Check Missing

## 類別
ERC4626 Integration / Protocol Logic

## 描述
當協議整合多個 ERC4626 vault 時，必須檢查每個 vault 的 `maxDeposit()` 限制。
只檢查內部 cap 而忽略外部限制，會導致交易 revert 或資金分配失敗。

## 漏洞模式

### 問題程式碼
```solidity
function _supplyToVaults(uint256 _assets) internal {
    for (uint256 i; i < vaults.length; ++i) {
        IERC4626 vault = vaults[i];
        uint256 cap = config[vault].cap;
        uint256 deposited = balanceOf[vault];
        
        // ❌ 只檢查內部 cap
        uint256 toSupply = min(cap - deposited, _assets);
        
        // 如果 vault.maxDeposit() < toSupply，會 revert
        vault.deposit(toSupply, address(this));
        _assets -= toSupply;
    }
}
```

### 攻擊場景
1. Vault A：內部 cap = 10,000，已存 5,000，可存 5,000
2. Vault B：內部 cap = 10,000，已存 5,000，可存 5,000
3. 但 Vault A 的實際 `maxDeposit()` = 3,000（因為其他用戶存款）

用戶嘗試存入 10,000：
- 計算 toSupply = 5,000（基於內部 cap）
- 嘗試 deposit(5,000) 到 Vault A
- Vault A.deposit() revert（因為 maxDeposit = 3,000）
- 整個交易失敗

## 影響
- 用戶無法存款，即使總容量足夠
- DoS 風險（如果所有 vault 的 maxDeposit 都低於內部 cap）
- 用戶體驗差（需要多次小額存款）

## 修復方式

### 正確實作
```solidity
function _supplyToVaults(uint256 _assets) internal {
    for (uint256 i; i < vaults.length; ++i) {
        IERC4626 vault = vaults[i];
        uint256 cap = config[vault].cap;
        uint256 deposited = balanceOf[vault];
        
        // ✅ 同時檢查內部 cap 和外部 maxDeposit
        uint256 internalLimit = cap - deposited;
        uint256 externalLimit = vault.maxDeposit(address(this));
        uint256 toSupply = min(min(internalLimit, externalLimit), _assets);
        
        if (toSupply > 0) {
            vault.deposit(toSupply, address(this));
            _assets -= toSupply;
        }
        
        if (_assets == 0) return;
    }
    
    // 剩餘資金保留為 idle（或 revert）
}
```

### 也要檢查 maxWithdraw
```solidity
function _withdrawFromVaults(uint256 _assets) internal {
    for (uint256 i; i < vaults.length; ++i) {
        IERC4626 vault = vaults[i];
        uint256 balance = vault.balanceOf(address(this));
        
        // ✅ 檢查 maxWithdraw
        uint256 maxWithdrawable = vault.maxWithdraw(address(this));
        uint256 toWithdraw = min(min(balance, maxWithdrawable), _assets);
        
        // ...
    }
}
```

## 相關 ERC4626 函數
- `maxDeposit(address)` - 最大可存入金額
- `maxMint(address)` - 最大可鑄造 shares
- `maxWithdraw(address)` - 最大可提取金額
- `maxRedeem(address)` - 最大可贖回 shares

## 檢測方法
1. 搜索 `deposit(`, `mint(`, `withdraw(`, `redeem(` 調用
2. 檢查是否有對應的 `max*()` 檢查
3. 特別注意循環中的批量操作

## 真實案例
- **Silo Finance 2025 (M-01)** - _supplyERC4626 未檢查 maxDeposit

## Checklist
- [ ] deposit 前檢查 maxDeposit()
- [ ] mint 前檢查 maxMint()
- [ ] withdraw 前檢查 maxWithdraw()
- [ ] redeem 前檢查 maxRedeem()
- [ ] 處理回傳 0 的情況（vault 暫停或滿）
- [ ] 處理 revert 的情況（try-catch）
