# DEX Slippage Protection Vulnerabilities

> Swap 操作中的滑點保護缺失模式

## Overview

與 DEX 交互時，滑點保護是防止 MEV 攻擊（三明治攻擊、front-running）的關鍵。許多協議在整合 Uniswap 等 DEX 時忽略了這一點。

**核心問題：** 開發者專注於「swap 能成功」，忽略了「swap 以合理價格成功」。

---

## 1. amountOutMinimum = 0 或 1 ⭐ Critical

**問題：** Swap 時設置 `amountOutMinimum` 為 0 或 1，完全放棄滑點保護。

### Uniswap V3 錯誤代碼

```solidity
// ❌ Critical：接受任意輸出
ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
    tokenIn: WETH,
    tokenOut: OLAS,
    fee: 3000,
    recipient: address(this),
    amountIn: amount,
    amountOutMinimum: 1,          // ⚠️ 接受 1 wei 作為輸出！
    sqrtPriceLimitX96: 0          // ⚠️ 無價格限制！
});
```

### Uniswap V2 錯誤代碼

```solidity
// ❌ Critical：接受零輸出
IUniswapV2Router02(router).swapExactTokensForTokens(
    amountIn,
    0,                            // ⚠️ 接受 0 作為最小輸出！
    path,
    recipient,
    block.timestamp
);
```

### 攻擊場景

```
1. 協議發起 buyBack(1000 ETH)
2. MEV bot 監控到交易
3. Front-run：大量賣出 OLAS → 價格暴跌
4. 協議交易執行：1000 ETH → 1 wei OLAS（滿足 amountOutMinimum = 1）
5. Back-run：bot 買回 OLAS → 價格恢復
6. 結果：協議損失 ~1000 ETH，bot 獲利
```

### 正確代碼

```solidity
// ✅ 使用 Oracle 計算預期輸出
function swap(uint256 amountIn) external {
    // 1. 獲取當前價格
    uint256 expectedOutput = oracle.getPrice() * amountIn / 1e18;
    
    // 2. 應用滑點容忍度（例如 1%）
    uint256 minOutput = expectedOutput * 99 / 100;
    
    // 3. 執行 swap
    ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({
        tokenIn: WETH,
        tokenOut: OLAS,
        fee: 3000,
        recipient: address(this),
        amountIn: amountIn,
        amountOutMinimum: minOutput,  // ✅ 有意義的最小值
        sqrtPriceLimitX96: 0
    });
    
    router.exactInputSingle(params);
}
```

### 影響
- **100% 資金損失** — 所有 swap 價值可被提取
- **每筆交易都脆弱** — 不是偶發問題，是必然被利用
- **直接經濟損失** — MEV bot 持續監控並提取

### 真實案例
- **Autonolas BuyBackBurnerUniswap (2026)**
  - V3 路徑：`amountOutMinimum: 1`
  - V2 路徑：`amountOutMin: 0`
  - 嚴重性：High

---

## 2. sqrtPriceLimitX96 = 0 ⭐ High

**問題：** Uniswap V3 的價格限制參數設為 0，允許在任意價格執行。

### 錯誤代碼

```solidity
// ❌ 無價格限制
params.sqrtPriceLimitX96 = 0;
```

### 問題解析

`sqrtPriceLimitX96` 是 Uniswap V3 的價格保護機制：
- 設為 0 = 無限制
- 買入時設置 = 最高可接受價格
- 賣出時設置 = 最低可接受價格

### 正確代碼

```solidity
// ✅ 設置價格限制
// 買入時：設置最高價格（當前價格 + 1%）
uint160 currentSqrtPrice = getCurrentSqrtPriceX96(pool);
uint160 maxPrice = currentSqrtPrice * 101 / 100;

params.sqrtPriceLimitX96 = maxPrice;
```

---

## 3. deadline = block.timestamp ⭐ Medium

**問題：** Swap deadline 設為 `block.timestamp`，等於沒有 deadline 保護。

### 錯誤代碼

```solidity
// ❌ Deadline 無意義
router.swapExactTokensForTokens(
    amountIn,
    amountOutMin,
    path,
    recipient,
    block.timestamp        // ⚠️ 永遠不會過期！
);
```

### 問題解析

`block.timestamp` 是交易被挖入時的時間，所以：
- 交易等待 1 分鐘 → deadline = 執行時的 timestamp → 永遠不過期
- MEV bot 可以 hold 交易，等到有利價格再執行

### 正確代碼

```solidity
// ✅ 設置實際 deadline
uint256 deadline = block.timestamp + 5 minutes; // 5 分鐘內必須執行

router.swapExactTokensForTokens(
    amountIn,
    amountOutMin,
    path,
    recipient,
    deadline
);
```

### 建議 Deadline

| 場景 | 建議 Deadline |
|------|--------------|
| 用戶交互 | 5-15 分鐘 |
| 自動化/Bot | 1-2 分鐘 |
| 時間敏感操作 | 30 秒 |

---

## 4. 缺少 Post-Swap 驗證 ⭐ Medium

**問題：** Swap 後不驗證實際收到的金額。

### 錯誤代碼

```solidity
// ❌ 不檢查實際收到多少
function buyBack(uint256 amountIn) external {
    router.swapExactTokensForTokens(amountIn, 1, path, address(this), deadline);
    // 假設 swap 成功就完事了
    _burn(olas.balanceOf(address(this)));
}
```

### 正確代碼

```solidity
// ✅ 驗證實際輸出
function buyBack(uint256 amountIn) external {
    uint256 balanceBefore = olas.balanceOf(address(this));
    
    uint256 expectedOutput = oracle.getPrice() * amountIn / 1e18;
    uint256 minOutput = expectedOutput * 99 / 100;
    
    router.swapExactTokensForTokens(amountIn, minOutput, path, address(this), deadline);
    
    uint256 actualOutput = olas.balanceOf(address(this)) - balanceBefore;
    
    // 額外驗證（對抗返回值欺騙）
    require(actualOutput >= minOutput, "Insufficient output");
    
    _burn(actualOutput);
}
```

---

## 5. 硬編碼滑點容忍度 ⭐ Low

**問題：** 滑點容忍度硬編碼，無法適應市場波動。

### 錯誤代碼

```solidity
// ❌ 硬編碼 1%
uint256 minOutput = expectedOutput * 99 / 100;
```

### 正確代碼

```solidity
// ✅ 可配置滑點
uint256 public maxSlippageBps = 100; // 1% = 100 bps

function setMaxSlippage(uint256 _maxSlippageBps) external onlyOwner {
    require(_maxSlippageBps <= 1000, "Max 10%"); // 防止設置過高
    maxSlippageBps = _maxSlippageBps;
}

function swap(uint256 amountIn) external {
    uint256 minOutput = expectedOutput * (10000 - maxSlippageBps) / 10000;
    // ...
}
```

---

## 6. Multi-Hop 滑點累積 ⭐ Medium

**問題：** 多跳 swap 時，滑點在每一跳累積，最終損失超出預期。

### 錯誤代碼

```solidity
// ❌ 三跳路徑，每跳 1% 滑點 = 總計 ~3% 損失
// A → B → C → D
router.swapExactTokensForTokens(amountIn, amountIn * 99 / 100, path, ...);
// 但實際：100 * 0.99 * 0.99 * 0.99 = 97.03
```

### 正確代碼

```solidity
// ✅ 根據跳數調整滑點
uint256 hops = path.length - 1;
uint256 slippagePerHop = 100; // 1%
uint256 totalSlippage = hops * slippagePerHop;

uint256 minOutput = amountIn * (10000 - totalSlippage) / 10000;
```

---

## Checklist

審計 DEX 整合時，檢查：

- [ ] **amountOutMin**：是否 > 0 且有意義？
- [ ] **sqrtPriceLimitX96**：V3 swap 是否設置價格限制？
- [ ] **deadline**：是否使用未來時間而非 `block.timestamp`？
- [ ] **Oracle 對照**：minOutput 是否基於 oracle 價格計算？
- [ ] **Post-swap 驗證**：是否驗證實際收到的金額？
- [ ] **可配置性**：滑點容忍度是否可調整？
- [ ] **Multi-hop**：多跳路徑是否考慮累積滑點？

---

## 快速檢測 Grep

```bash
# 找可疑的 V2 swap
grep -rn "swapExactTokensForTokens.*,\s*0\s*," contracts/

# 找可疑的 V3 swap
grep -rn "amountOutMinimum:\s*[01]\s*[,}]" contracts/
grep -rn "sqrtPriceLimitX96:\s*0" contracts/

# 找 block.timestamp 作為 deadline
grep -rn "block\.timestamp\s*[,)]" contracts/ | grep -i swap
```

---

## 相關模式

- [Flash Loan Patterns](../flash-loan/flash-loan-patterns.md) — 閃電貸如何放大滑點攻擊
- [Oracle Staleness](oracle-staleness.md) — 過期 Oracle 導致錯誤的 minOutput 計算

---

*Created: 2026-01-31 | Source: Autonolas audit findings*
