# Access Control Vulnerability Patterns

## Pattern 0: Unprotected Initializer (First-Caller Takeover)

### Description
Proxy 合約的 `initialize()` 函數沒有保護，任何人都可以搶先調用成為 owner。

### Vulnerable Code
```solidity
contract MyContract {
    address public owner;
    
    // ❌ 任何人都能調用
    function initialize(address _treasury) external {
        require(owner == address(0), "Already initialized");
        owner = msg.sender;  // 第一個調用者成為 owner
        treasury = _treasury;
    }
}
```

### Attack
```
1. 監控 proxy 部署交易
2. 搶先調用 initialize()
3. 成為 owner
4. 調用 owner-only 函數（如 changeImplementation）
5. 完全控制合約
```

### Correct Code
```solidity
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
    address public owner;
    
    // ✅ 使用 initializer modifier
    function initialize(address _treasury) external initializer {
        owner = msg.sender;
        treasury = _treasury;
    }
}

// 或者在 constructor 設置 deployer
constructor() {
    _disableInitializers();  // 防止實現合約被初始化
}
```

### Detection Checklist
- [ ] `initialize()` 是 external/public？
- [ ] 只用 `owner == address(0)` 做檢查？
- [ ] 沒有 `initializer` modifier？
- [ ] Constructor 沒設置任何保護？

### Real Case: Olas ServiceManager, Tokenomics, LiquidityManager
多個合約都有這個問題，V12 標記為 Qa/High。

---

> 來源：Code4rena, Sherlock 2024 審計報告
> 整理：5 個 High Severity 案例

## Overview

Access Control 漏洞是最常見也最危險的漏洞類型之一。缺少或不正確的權限檢查可導致資金損失、協議被接管。

---

## 1. Missing Access Control on Critical Setter (Decent 2024-01) ⭐ 最常見

**來源：** [Code4rena H-01](https://code4rena.com/reports/2024-01-decent) - 65+ 人發現

**問題：** `setRouter()` 函數沒有權限控制，任何人都可以設置 router 地址。

**漏洞代碼：**
```solidity
// ❌ 沒有 access control！
function setRouter(address _router) public {
    router = _router;
}

// mint/burn 只能由 router 調用
function mint(address _to, uint256 _amount) public onlyRouter {
    _mint(_to, _amount);
}

function burn(address _from, uint256 _amount) public onlyRouter {
    _burn(_from, _amount);
}
```

**攻擊流程：**
1. 攻擊者調用 `setRouter(attackerAddress)`
2. 現在攻擊者可以調用 `mint()` 無限鑄造 token
3. 用這些 token 提取協議中所有 WETH
4. 或者調用 `burn()` 銷毀流動性提供者的 token

**影響：** 整個 TVL 可被盜。

**修復：**
```solidity
function setRouter(address _router) public onlyOwner {
    router = _router;
}
```

**審計重點：** 任何 `set*` 函數都必須檢查權限！

---

## 2. External Call Without Authorization Check (Salty 2024-01)

**來源：** [Code4rena H-01](https://code4rena.com/reports/2024-01-salty)

**問題：** OpenZeppelin VestingWallet 的 `release()` 沒有權限控制，任何人都可以觸發。

**背景代碼：**
```solidity
// OZ VestingWallet - release() 是 public，無權限控制
function release(address token) public virtual {
    uint256 amount = releasable(token);
    _erc20Released[token] += amount;
    SafeERC20.safeTransfer(IERC20(token), beneficiary(), amount);
}
```

**Upkeep 合約的錯誤假設：**
```solidity
function step11() public onlySameContract {
    // 計算可釋放金額
    uint256 releaseableAmount = VestingWallet(...).releasable(address(salt));
    
    // 調用 release
    VestingWallet(...).release(address(salt));
    
    // ❌ 假設 releaseableAmount 就是剛剛釋放的金額
    salt.safeTransfer(managedTeamWallet.mainWallet(), releaseableAmount);
}
```

**攻擊流程：**
1. 攻擊者直接調用 `VestingWallet.release()`
2. Token 被發送到 beneficiary (Upkeep 合約)
3. 當 `step11()` 被調用時，`releasable()` 返回 0
4. 但之前釋放的 token 永久卡在 Upkeep 合約

**教訓：** 整合外部合約時，必須了解其權限模型。

---

## 3. First Depositor Advantage (Salty 2024-01)

**來源：** [Code4rena H-02](https://code4rena.com/reports/2024-01-salty)

**問題：** 第一個 LP 可以 claim 所有初始獎勵。

**漏洞代碼：**
```solidity
function _increaseUserShare(...) internal {
    uint256 existingTotalShares = totalShares[poolID];
    
    if (existingTotalShares != 0) {  // ❌ 第一個人跳過這段
        uint256 virtualRewardsToAdd = Math.ceilDiv(
            totalRewards[poolID] * increaseShareAmount, 
            existingTotalShares
        );
        user.virtualRewards += uint128(virtualRewardsToAdd);
    }
    
    user.userShare += uint128(increaseShareAmount);
    totalShares[poolID] = existingTotalShares + increaseShareAmount;
}
```

**獎勵計算：**
```solidity
function userRewardForPool(...) public view returns (uint256) {
    uint256 rewardsShare = (totalRewards[poolID] * user.userShare) / totalShares[poolID];
    return rewardsShare - user.virtualRewards;
    // 第一個人：virtualRewards = 0，可以拿走所有 rewards！
}
```

**攻擊流程：**
1. 等待協議上線（投票期間獎勵累積）
2. 第一個存入少量 LP
3. 調用 `upkeep.performUpkeep()` 觸發獎勵分配
4. 立即 claim 所有獎勵（~5.5K SALT per pool）

**修復：** 在 `finalizeBallot()` 開始時調用 `performUpkeep()` 重置計時器。

---

## 4. Missing LayerZero Gas Validation (Decent 2024-01)

**來源：** [Code4rena H-02](https://code4rena.com/reports/2024-01-decent)

**問題：** 沒有驗證用戶提供的 gas 是否足夠。

**漏洞代碼：**
```solidity
function _getCallParams(...) private view returns (...) {
    uint256 GAS_FOR_RELAY = 100000;
    uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;  // ❌ 沒驗證 _dstGasForCall
    adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);
}

function bridgeWithPayload(
    uint16 _dstChainId,
    address _toAddress,
    uint _amount,
    bool deliverEth,
    uint64 _dstGasForCall,  // ❌ 用戶可傳入任意小的值
    bytes memory additionalPayload
) public payable { ... }
```

**攻擊/問題：**
1. 用戶傳入很小的 `_dstGasForCall`（如 1000）
2. 目標鏈執行時 gas 不足
3. 消息狀態變為 STORED
4. 阻塞該路徑上的所有後續消息

**LayerZero 推薦：**
- EVM 鏈：200,000 gas
- Arbitrum：2,000,000 gas

**修復：** 加入最小 gas 檢查：
```solidity
require(_dstGasForCall >= MIN_DST_GAS, "Insufficient gas");
```

---

## 5. Unprotected Initialization (通用模式)

**問題：** `initialize()` 函數沒有保護，可被前置交易。

**漏洞代碼：**
```solidity
// ❌ 任何人都可以調用
function initialize(address _owner, address _token) external {
    require(!initialized, "Already initialized");
    initialized = true;
    owner = _owner;
    token = _token;
}
```

**攻擊流程：**
1. 監控 mempool 中的部署交易
2. 前置交易調用 `initialize(attackerAddress, ...)`
3. 攻擊者成為 owner

**修復方案：**

### 方案 1: Initializer Guard
```solidity
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

function initialize(...) external initializer {
    // ...
}
```

### 方案 2: Constructor 設置
```solidity
constructor() {
    _disableInitializers();
}
```

### 方案 3: 部署時原子初始化
```solidity
// 在同一交易中部署並初始化
bytes memory initData = abi.encodeCall(Contract.initialize, (owner, token));
new TransparentUpgradeableProxy(impl, admin, initData);
```

---

## Access Control 類型總結

| 類型 | 描述 | 嚴重性 |
|------|------|--------|
| Missing Modifier | 函數缺少 `onlyOwner` 等 modifier | Critical |
| Wrong Modifier | 用了錯誤的權限檢查 | High |
| Front-running Init | `initialize()` 可被搶先 | High |
| Role Confusion | 角色權限分配錯誤 | High |
| External Dependency | 依賴外部合約的權限模型 | Medium |

---

## 審計 Checklist

| # | 檢查項目 | 嚴重性 |
|---|---------|--------|
| 1 | 所有 `set*` 函數是否有權限控制？ | Critical |
| 2 | `initialize()` 是否受保護？ | High |
| 3 | 關鍵函數是否有 `onlyOwner/onlyAdmin`？ | High |
| 4 | 外部合約的權限模型是否被正確理解？ | Medium |
| 5 | 是否有不該 public 的函數？ | High |
| 6 | 第一個用戶是否有特殊優勢？ | Medium |
| 7 | 跨鏈調用是否驗證了 gas？ | High |

---

## 常見修復模式

### 1. OpenZeppelin Ownable
```solidity
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyContract is Ownable {
    function setRouter(address _router) external onlyOwner {
        router = _router;
    }
}
```

### 2. Role-Based Access Control
```solidity
import "@openzeppelin/contracts/access/AccessControl.sol";

contract MyContract is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    
    function setRouter(address _router) external onlyRole(ADMIN_ROLE) {
        router = _router;
    }
}
```

### 3. Two-Step Transfer
```solidity
function transferOwnership(address newOwner) external onlyOwner {
    pendingOwner = newOwner;
}

function acceptOwnership() external {
    require(msg.sender == pendingOwner, "Not pending owner");
    owner = pendingOwner;
    pendingOwner = address(0);
}
```

---

## 高風險函數關鍵字

審計時特別關注以下函數名：
- `set*`, `update*`, `change*`
- `initialize`, `init`, `setup`
- `withdraw`, `transfer`, `send`
- `mint`, `burn`
- `pause`, `unpause`, `kill`
- `upgrade`, `migrate`
- `addAdmin`, `removeAdmin`, `grantRole`

---

## 參考資源

- [OpenZeppelin Access Control](https://docs.openzeppelin.com/contracts/4.x/access-control)
- [SWC-105: Unprotected Ether Withdrawal](https://swcregistry.io/docs/SWC-105)
- [LayerZero Integration Checklist](https://layerzero.gitbook.io/docs/troubleshooting/layerzero-integration-checklist)
