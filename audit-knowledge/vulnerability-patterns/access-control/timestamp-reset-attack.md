# 時間戳重設攻擊 (Timestamp Reset Attack)

## 風險等級
**Medium / High** - 可繞過時間限制或造成 DoS

## 描述
合約允許特權用戶重設時間戳變數，可能被用來繞過冷卻期限制或阻止正常操作。

## 漏洞模式

```solidity
// ❌ QuantAMM - UpdateWeightRunner.sol
function InitialisePoolLastRunTime(address _poolAddress, uint40 _time) external {
    // Pool Manager 可以設置任意時間戳
    if (poolRegistryEntry & MASK_POOL_OWNER_UPDATES > 0) {
        require(msg.sender == poolRuleSettings[_poolAddress].poolManager, "ONLYMANAGER");
    }
    
    poolRuleSettings[_poolAddress].timingSettings.lastPoolUpdateRun = _time;
    // ❌ 沒有限制 _time 的範圍
}

// 正常的更新檢查
function performUpdate(address _pool) public {
    require(
        block.timestamp - settings.timingSettings.lastPoolUpdateRun >= settings.timingSettings.updateInterval,
        "Update not allowed"
    );
    // ...
}
```

## 攻擊場景

### 場景 1: DoS 攻擊（設為未來時間）
```solidity
// 攻擊者是 Pool Manager
attacker.InitialisePoolLastRunTime(pool, type(uint40).max);

// 現在 block.timestamp - lastPoolUpdateRun 會下溢
// 或者永遠無法滿足 >= updateInterval
// 池子被永久凍結
```

### 場景 2: 繞過冷卻期（設為過去時間）
```solidity
// 正常情況：每小時只能更新一次
// updateInterval = 3600

// 攻擊者重設時間戳
attacker.InitialisePoolLastRunTime(pool, 0);

// 現在可以立即觸發更新
// block.timestamp - 0 >= 3600  // true
```

### 場景 3: 連續更新攻擊
```solidity
// 攻擊者持續重設時間戳
for (uint i = 0; i < 100; i++) {
    attacker.InitialisePoolLastRunTime(pool, 0);
    attacker.performUpdate(pool);
    // 快速連續更新，可能造成極端權重變化
}
```

## 影響

1. **DoS** - 池子無法更新權重
2. **繞過限制** - 無視冷卻期快速更新
3. **經濟攻擊** - 配合 Oracle 操縱放大效果
4. **不可預期行為** - 時間相關邏輯失效

## 檢測方法

### 1. 找時間戳設置函數
```bash
grep -rn "lastUpdate\|lastRun\|timestamp.*=" contracts/ | grep -v "block.timestamp"
```

### 2. 檢查設置限制
```solidity
// 檢查是否有：
// - 範圍限制
// - 只能向前不能向後
// - 與 block.timestamp 的合理差距
```

### 3. 審計 Checklist
```markdown
- [ ] 時間戳設置有最大值限制？
- [ ] 時間戳設置有最小值限制？
- [ ] 只能增加不能減少？
- [ ] 需要時間鎖？
- [ ] emit 事件便於監控？
```

## 修復方式

### 方案 1: 限制範圍
```solidity
function InitialisePoolLastRunTime(address _pool, uint40 _time) external {
    require(_time <= block.timestamp, "Cannot set future time");
    require(_time >= block.timestamp - MAX_LOOKBACK, "Time too far in past");
    // ...
}
```

### 方案 2: 只允許重設為當前時間
```solidity
function resetPoolLastRunTime(address _pool) external {
    // 只能重設為現在，用於緊急情況
    poolRuleSettings[_pool].timingSettings.lastPoolUpdateRun = uint40(block.timestamp);
}
```

### 方案 3: 時間鎖 + 多簽
```solidity
function scheduleTimeReset(address _pool, uint40 _time) external {
    require(msg.sender == timelock, "Only timelock");
    // 兩天後才能執行
    pendingTimeResets[_pool] = TimestampReset({
        newTime: _time,
        executeAfter: block.timestamp + 2 days
    });
}
```

### 方案 4: 禁止任意設置
```solidity
// 完全移除該函數，或只在初始化時使用
function initialize(...) external {
    require(!initialized, "Already initialized");
    lastPoolUpdateRun = uint40(block.timestamp);
    initialized = true;
}
```

## 真實案例

| 專案 | 位置 | 問題 | 影響 |
|------|------|------|------|
| QuantAMM 2024 | UpdateWeightRunner | 可設任意時間 | DoS / 繞過冷卻 |

## 相關模式
- [missing-access-control.md](./missing-access-control.md) (待新增)
- [privilege-escalation.md](./privilege-escalation.md) (待新增)

## 標籤
`access-control` `timestamp` `dos` `medium-severity`
