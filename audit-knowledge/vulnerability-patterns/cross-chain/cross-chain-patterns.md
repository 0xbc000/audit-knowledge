# Cross-Chain / Bridge Vulnerability Patterns

## Overview

Cross-chain protocols move assets/messages between blockchains.
High-value targets: bridges often hold massive TVL.

---

## Pattern 1: Message Replay Attack

### Description
Same message valid on multiple chains or can be replayed.

### Vulnerable Code
```solidity
function processMessage(bytes calldata message, bytes calldata signature) external {
    // Missing chain ID in signed data!
    bytes32 hash = keccak256(message);
    address signer = ECDSA.recover(hash, signature);
    require(signer == relayer, "Invalid signer");
    
    // Process without replay protection
    _executeMessage(message);
}
```

### Attack
```
1. Capture valid message on Chain A
2. Replay same message on Chain B
3. Double-spend or duplicate action
```

### Detection
- [ ] Message hash includes chain ID?
- [ ] Nonce or unique identifier tracked?
- [ ] Same contracts deployed with same addresses cross-chain?

### Fix
```solidity
function processMessage(bytes calldata message, bytes calldata signature) external {
    bytes32 hash = keccak256(abi.encodePacked(
        block.chainid,      // Chain ID
        address(this),      // Contract address
        nonce++,            // Replay protection
        message
    ));
    require(!processedMessages[hash], "Already processed");
    processedMessages[hash] = true;
    // ... verify and execute
}
```

---

## Pattern 2: Improper Message Verification

### Description
Insufficient validation of cross-chain message authenticity.

### Vulnerable Code
```solidity
function receiveMessage(
    uint16 srcChainId,
    bytes calldata srcAddress,
    bytes calldata payload
) external {
    // Only checks it came from "bridge" but not the original sender!
    require(msg.sender == bridge, "Not bridge");
    
    // Blindly trusts srcAddress without verification
    _processPayload(payload);
}
```

### Attack
```
1. Deploy malicious contract on source chain
2. Send message through legitimate bridge
3. Destination trusts message due to bridge origin
```

### Detection
- [ ] Source address validated against whitelist?
- [ ] Message origin contract verified?
- [ ] Payload contents validated?

### Fix
```solidity
mapping(uint16 => bytes) public trustedRemotes;

function receiveMessage(
    uint16 srcChainId,
    bytes calldata srcAddress,
    bytes calldata payload
) external {
    require(msg.sender == bridge, "Not bridge");
    require(
        keccak256(srcAddress) == keccak256(trustedRemotes[srcChainId]),
        "Not trusted source"
    );
    _processPayload(payload);
}
```

---

## Pattern 3: Sequencer/Relayer Trust Issues

### Description
Over-reliance on centralized sequencer or relayer.

### Vulnerable Patterns
```solidity
// Single relayer can censor or front-run
function submitBatch(bytes[] calldata messages) external onlyRelayer {
    for (uint i = 0; i < messages.length; i++) {
        _process(messages[i]);
    }
}

// Relayer can choose ordering
function processInOrder(bytes[] calldata messages) external onlyRelayer {
    // MEV opportunity for relayer
}
```

### Issues
- Relayer can censor specific messages
- Relayer can reorder for MEV
- Single point of failure

### Detection
- [ ] Single relayer/sequencer?
- [ ] Can relayer selectively process?
- [ ] Timeout mechanism if relayer offline?

### Fix
```solidity
// Timeout-based permissionless processing
mapping(bytes32 => uint256) public messageTimestamp;

function submitMessage(bytes calldata message) external {
    messageTimestamp[keccak256(message)] = block.timestamp;
}

function processMessage(bytes calldata message) external {
    bytes32 hash = keccak256(message);
    require(messageTimestamp[hash] != 0, "Not submitted");
    
    // After timeout, anyone can process
    if (msg.sender != relayer) {
        require(
            block.timestamp > messageTimestamp[hash] + TIMEOUT,
            "Wait for timeout"
        );
    }
    _process(message);
}
```

---

## Pattern 4: Token Mapping Mismatch

### Description
Incorrect mapping between tokens across chains.

### Vulnerable Code
```solidity
// Admin can map any token to any token
function setTokenMapping(
    address localToken,
    uint16 remoteChain,
    address remoteToken
) external onlyAdmin {
    tokenMappings[localToken][remoteChain] = remoteToken;
}

function bridge(address token, uint256 amount) external {
    // Trusts mapping is correct
    address remoteToken = tokenMappings[token][destChain];
    _lockAndMint(token, remoteToken, amount);
}
```

### Attack
```
1. Admin (malicious or compromised) maps USDC → attacker's fake token
2. Users bridge USDC, receive worthless token on destination
3. Real USDC locked forever
```

### Detection
- [ ] Token mappings verified on both chains?
- [ ] Mapping changes have timelock?
- [ ] Canonical token registry?

### Fix
```solidity
// Use CREATE2 deterministic addresses
function getCanonicalToken(address sourceToken, uint16 sourceChain) 
    public pure returns (address) 
{
    return address(uint160(uint256(keccak256(abi.encodePacked(
        sourceChain,
        sourceToken,
        SALT
    )))));
}
```

---

## Pattern 5: Finality Assumptions

### Description
Acting on messages before source chain reaches finality.

### Vulnerable Code
```solidity
function receiveMessage(bytes calldata message) external {
    // Processes immediately without finality check
    _executeMessage(message);
}
```

### Attack (Chain Reorg)
```
1. Send bridge message on source chain
2. Message relayed to destination
3. Destination processes, releases funds
4. Source chain reorgs, original tx disappears
5. Attacker has funds on both chains
```

### Detection
- [ ] Finality period enforced?
- [ ] Challenge period for large transfers?
- [ ] Fraud proofs implemented?

### Fix
```solidity
mapping(bytes32 => uint256) public messageTimestamp;
uint256 public constant FINALITY_DELAY = 15 minutes;

function queueMessage(bytes calldata message) external onlyRelayer {
    messageTimestamp[keccak256(message)] = block.timestamp;
}

function executeMessage(bytes calldata message) external {
    bytes32 hash = keccak256(message);
    require(
        block.timestamp >= messageTimestamp[hash] + FINALITY_DELAY,
        "Finality not reached"
    );
    delete messageTimestamp[hash];
    _executeMessage(message);
}
```

---

## Pattern 6: Reentrancy via Bridge Callback

### Description
Bridge callbacks enable cross-contract reentrancy.

### Vulnerable Flow
```
Bridge.deliver() 
  → Target.onMessageReceive()
    → Target calls back to Bridge or other contracts
      → State inconsistency
```

### Detection
- [ ] Callback to user-controlled address?
- [ ] State changes after callback?
- [ ] Cross-contract calls in callback?

### Fix
- Reentrancy guards across related contracts
- Checks-Effects-Interactions pattern
- Pull-based fund distribution

---

## Quick Reference

| Attack Type | Key Indicator | Mitigation |
|-------------|---------------|------------|
| Replay | No chainId/nonce | Include both + track processed |
| Bad Verification | Trust bridge only | Verify source address |
| Relayer Centralization | Single relayer | Timeout + permissionless fallback |
| Token Mismatch | Admin-controlled mapping | Deterministic addresses |
| No Finality | Immediate processing | Delay + challenge period |
| Callback Reentrancy | External call in handler | nonReentrant + CEI |

## Historical Exploits

| Protocol | Loss | Root Cause |
|----------|------|------------|
| Ronin | $624M | Compromised validators (5/9) |
| Wormhole | $326M | Signature verification bypass |
| Nomad | $190M | Improper message validation |
| Multichain | $126M | MPC key compromise |
| Harmony | $100M | Compromised multisig (2/5) |

## Minimal Reproduction (Pattern 1: Message Replay)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract VulnerableBridge {
    address public relayer;
    mapping(address => uint256) public balances;

    constructor(address _relayer) { relayer = _relayer; }

    function deposit() external payable { balances[msg.sender] += msg.value; }

    // ❌ No chainId, no nonce, no replay tracking
    function processMessage(bytes calldata message, bytes calldata sig) external {
        bytes32 hash = keccak256(message);
        (address to, uint256 amt) = abi.decode(message, (address, uint256));
        // simplified: skip sig verification for demo
        balances[to] += amt;
    }
}
```

### Foundry Test Draft

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

// paste VulnerableBridge above

contract MessageReplayTest is Test {
    VulnerableBridge bridge;

    function setUp() public {
        bridge = new VulnerableBridge(address(this));
        vm.deal(address(bridge), 10 ether);
    }

    function testMessageReplay() public {
        bytes memory msg_ = abi.encode(address(this), 1 ether);
        bridge.processMessage(msg_, "");
        uint256 bal1 = bridge.balances(address(this));
        // Replay same message
        bridge.processMessage(msg_, "");
        uint256 bal2 = bridge.balances(address(this));
        assertEq(bal2, bal1 * 2, "replay doubled balance");
    }
}
```

---

## Related Patterns
- `access-control/` - Relayer/admin permissions
- `upgrade/` - Bridge upgrade risks
- `oracle/` - Cross-chain oracle issues
