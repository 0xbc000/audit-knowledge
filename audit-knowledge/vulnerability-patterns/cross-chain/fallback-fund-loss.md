# Fallback Logic Causing Fund Loss

## 問題描述

跨鏈交易的回退（fallback）邏輯錯誤可能導致資金：
1. 發送到錯誤地址
2. 卡在合約中無法提取
3. 永久鎖定在中間狀態

## 漏洞模式

### 模式 1：錯誤的回退目標

```solidity
// ❌ dcntEth 發到執行目標而非用戶
if (weth.balanceOf(address(this)) < _amount) {
    dcntEth.transfer(_to, _amount);  // _to = bridge adapter, not user
    return;
}
```

### 模式 2：Stargate 緩存導致永久鎖定

```solidity
// ❌ swap 失敗但 payload 被緩存
function sgReceive(...) external {
    // Stargate 已轉入 token
    
    // 如果 swap 失敗（如 slippage 過時）
    UTB.receiveFromBridge(...);  // 這會 revert
    
    // Stargate 會緩存 payload，但重試用相同參數還是會失敗
    // Token 永久卡在 adapter
}
```

## 安全模式

### 明確的用戶 refund 地址

```solidity
// ✅ 傳入明確的 refund 地址
struct CrossChainPayload {
    address user;           // 原始用戶
    address executor;       // 執行目標
    address refundTo;       // 回退地址
}

if (weth.balanceOf(address(this)) < _amount) {
    dcntEth.transfer(payload.refundTo, _amount);  // ✅ 明確
    return;
}
```

### Try-Catch 包裝

```solidity
// ✅ Stargate 回退安全
function sgReceive(
    address token,
    uint256 amountLD,
    bytes memory payload
) external {
    (address refundTo, bytes memory swapData) = abi.decode(payload, ...);
    
    try this.executeSwap(swapData) {
        // 成功
    } catch {
        // ✅ 失敗時直接返還用戶
        IERC20(token).transfer(refundTo, amountLD);
    }
}
```

## 受影響協議

- Decent Bridge (H-04, M-01) - 2024-01

## 檢查清單

- [ ] 每個 fallback 路徑的資金去向是否明確？
- [ ] 是否發到用戶控制的地址？
- [ ] 緩存/重試機制是否會導致永久鎖定？
- [ ] swap 參數過時時如何處理？
