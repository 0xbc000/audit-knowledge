# Cross-Chain Address Encoding Issues

## 問題描述

跨鏈 payload 中編碼的地址必須是**目標鏈上有效的地址**。常見錯誤：
1. 將源鏈合約地址當作目標鏈 refund 地址
2. 不同鏈上合約地址不同（非 CREATE2 部署）
3. 目標鏈上該地址可能是 EOA、其他合約、或不存在

## 漏洞模式

```solidity
// ❌ 源鏈編碼
function _getCallParams(...) view returns (...) {
    payload = abi.encode(
        msgType,
        msg.sender,     // = DecentBridgeAdapter (源鏈地址)
        _toAddress,
        deliverEth
    );
}

// ❌ 目標鏈使用
function onReceive(bytes memory _payload) external {
    (uint8 msgType, address _from, ...) = abi.decode(_payload, ...);
    
    if (!success) {
        payable(_from).transfer(amount);  // ❌ 錯誤地址
    }
}
```

## 為什麼地址會不同？

1. **CREATE 部署** - 地址 = hash(deployer, nonce)，不同鏈 nonce 不同
2. **CREATE2 部署** - 地址 = hash(factory, salt, bytecode)，可以相同
3. **大多數協議用 CREATE** - 所以地址通常不同

## 安全模式

```solidity
// ✅ 明確傳入目標鏈 refund 地址
function bridge(
    address _dstRefundAddress,  // 用戶的目標鏈地址
    ...
) public {
    payload = abi.encode(
        msgType,
        _dstRefundAddress,  // ✅ 明確指定
        ...
    );
}

// ✅ 或使用 relayer 機制返還源鏈
function onReceive(bytes memory _payload) external {
    if (!success) {
        // 發送跨鏈訊息返還源鏈
        _sendRefundToSourceChain(amount, originalSender);
    }
}
```

## 受影響協議

- Decent Bridge (H-03) - 2024-01

## 檢查清單

- [ ] payload 中的地址在目標鏈有效嗎？
- [ ] refund 地址是用戶指定的還是自動編碼的？
- [ ] 合約是用 CREATE 還是 CREATE2 部署？
- [ ] 失敗路徑是否正確處理地址？
