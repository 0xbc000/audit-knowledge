# ecrecover Pitfalls

## 風險等級
**High** — 可導致任意地址偽造、簽名偽造

## 描述

`ecrecover` 是 Solidity 底層簽名驗證函數，有多個陷阱：

1. **Invalid signature → returns address(0)** 而非 revert
2. **Signature malleability** — 同一訊息可產生兩個有效簽名
3. **Hash 前缀缺失** — 未加 `\x19Ethereum Signed Message` 前缀

## 漏洞模式

### 模式 1: 未檢查 address(0)

```solidity
// ❌ VULNERABLE — 如果 owner == address(0)（未初始化），任何無效簽名都能通過
function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) external view returns (bool) {
    address recovered = ecrecover(hash, v, r, s);
    return recovered == owner; // 如果 owner 是 address(0)...
}
```

```solidity
// ✅ FIXED
function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) external view returns (bool) {
    address recovered = ecrecover(hash, v, r, s);
    require(recovered != address(0), "Invalid signature");
    return recovered == owner;
}
```

### 模式 2: Signature Malleability

ECDSA 簽名 `(v, r, s)` 有對稱性：`(v, r, s)` 和 `(v', r, n-s)` 都是有效簽名（n = secp256k1 order）。

```solidity
// ❌ VULNERABLE — 攻擊者可以用 (v', r, n-s) 繞過 usedSignatures
mapping(bytes32 => bool) usedSignatures;

function execute(bytes32 hash, uint8 v, bytes32 r, bytes32 s) external {
    bytes32 sigHash = keccak256(abi.encodePacked(v, r, s));
    require(!usedSignatures[sigHash], "Used");
    
    address signer = ecrecover(hash, v, r, s);
    require(signer == admin, "Bad sig");
    
    usedSignatures[sigHash] = true;
    // 執行操作...
}
// 攻擊: 第一次用 (v,r,s)，第二次用 (v',r,n-s)，不同 sigHash 但同一 signer
```

```solidity
// ✅ FIXED — 使用 OpenZeppelin ECDSA，強制 s 在 lower half
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

function execute(bytes32 hash, bytes memory signature) external {
    // ECDSA.recover 自動拒絕 malleable signatures
    address signer = ECDSA.recover(hash, signature);
    require(signer == admin, "Bad sig");
    
    // 用 hash 而非 signature 做去重
    require(!usedHashes[hash], "Used");
    usedHashes[hash] = true;
}
```

### 模式 3: 缺少 Ethereum Signed Message 前缀

```solidity
// ❌ VULNERABLE — 直接用原始 hash，可能和交易簽名衝突
bytes32 hash = keccak256(abi.encodePacked(data));
ecrecover(hash, v, r, s);

// ✅ FIXED — 加上 EIP-191 前缀
bytes32 hash = keccak256(abi.encodePacked(
    "\x19Ethereum Signed Message:\n32",
    keccak256(abi.encodePacked(data))
));
// 或直接用 ECDSA.toEthSignedMessageHash()
```

## 真實案例

### 0x Protocol (2019)
- `ecrecover` 返回 `address(0)` 被用於匹配無主訂單
- 任何人可以免費執行「空」訂單

### Sushi Trident (2022)
- Signature malleability 允許 permit 重放
- 發現於審計階段，未造成損失

## 檢測方法

```bash
# 找直接使用 ecrecover（而非 OZ ECDSA）
grep -rn "ecrecover" contracts/ --include="*.sol" | grep -v "import\|//"

# 確認是否檢查返回值
# 如果 ecrecover 後沒有 != address(0) 檢查 → 潛在問題
```

## Foundry PoC: Malleability 攻擊

```solidity
function test_malleability() public {
    bytes32 hash = keccak256("test");
    (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, hash);
    
    // 計算 malleable signature
    uint256 n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
    uint8 v2 = v == 27 ? 28 : 27;
    bytes32 s2 = bytes32(n - uint256(s));
    
    // 兩者都能 recover 出同一地址
    address a1 = ecrecover(hash, v, r, s);
    address a2 = ecrecover(hash, v2, r, s2);
    assertEq(a1, a2); // Same signer!
    
    // 但 OZ ECDSA 會拒絕 high-s
    vm.expectRevert("ECDSA: invalid signature 's' value");
    ECDSA.recover(hash, abi.encodePacked(r, s2, v2));
}
```

## 最佳實踐

1. **永遠用 OpenZeppelin ECDSA** 而非裸 `ecrecover`
2. **去重用 message hash** 而非 signature bytes
3. **檢查 recovered address != address(0)**
4. 使用 EIP-191 或 EIP-712 結構化簽名

## 標籤
`signature` `ecrecover` `malleability` `address-zero` `high-severity`
