# EIP-712 Implementation Mistakes

## 風險等級
**Medium ~ High** — 可導致簽名偽造、跨合約重放

## 描述

EIP-712 定義了結構化資料簽名標準，但實作上有多個常見錯誤。

## 漏洞模式

### 模式 1: TypeHash 與實際 Struct 不匹配

```solidity
// ❌ VULNERABLE — typeHash 的參數順序/名稱和 struct 不同
bytes32 constant ORDER_TYPEHASH = keccak256(
    "Order(address maker,uint256 amount,uint256 price)"
);

struct Order {
    address maker;
    uint256 price;    // 注意: 順序和 typeHash 不同！
    uint256 amount;
}

function hashOrder(Order memory order) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        ORDER_TYPEHASH,
        order.maker,
        order.amount,  // 這裡用 typeHash 的順序...
        order.price    // 但 struct 裡是反的
    ));
    // 結果: 前端和合約產生不同的 hash
}
```

### 模式 2: 巢狀 Struct 未正確 Hash

```solidity
// ❌ VULNERABLE — 巢狀 struct 直接 abi.encode 而非遞迴 hash
bytes32 constant ORDER_TYPEHASH = keccak256(
    "Order(address maker,Asset asset)Asset(address token,uint256 amount)"
);

function hashOrder(Order memory o) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        ORDER_TYPEHASH,
        o.maker,
        o.asset  // ❌ 巢狀 struct 要先 hash！
    ));
}

// ✅ FIXED
function hashOrder(Order memory o) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        ORDER_TYPEHASH,
        o.maker,
        hashAsset(o.asset)  // 遞迴 hash
    ));
}

function hashAsset(Asset memory a) internal pure returns (bytes32) {
    return keccak256(abi.encode(ASSET_TYPEHASH, a.token, a.amount));
}
```

### 模式 3: Dynamic Types 未正確處理

```solidity
// ❌ VULNERABLE — bytes/string 要用 keccak256，array 要逐一 hash
bytes32 constant MSG_TYPEHASH = keccak256(
    "Message(string text,uint256[] values)"
);

function hashMessage(string memory text, uint256[] memory values) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        MSG_TYPEHASH,
        text,     // ❌ string 要 keccak256(bytes(text))
        values    // ❌ array 要 keccak256(abi.encodePacked(values))
    ));
}

// ✅ FIXED
function hashMessage(string memory text, uint256[] memory values) internal pure returns (bytes32) {
    return keccak256(abi.encode(
        MSG_TYPEHASH,
        keccak256(bytes(text)),
        keccak256(abi.encodePacked(values))
    ));
}
```

### 模式 4: abi.encodePacked 用於 struct hash（hash collision）

```solidity
// ❌ VULNERABLE — encodePacked 會導致不同參數產生相同 hash
bytes32 hash = keccak256(abi.encodePacked(typeHash, addr, amount));
// (addr=0x00...01, amount=2) 和 (addr=0x00...012, amount=?) 可能碰撞

// ✅ FIXED — struct hash 永遠用 abi.encode
bytes32 hash = keccak256(abi.encode(typeHash, addr, amount));
```

## 檢測方法

```bash
# 找 EIP-712 相關代碼
grep -rn "TYPEHASH\|_hashTypedDataV4\|712" contracts/ --include="*.sol"

# 找 encodePacked 用於 hash（潛在碰撞）
grep -rn "keccak256(abi.encodePacked" contracts/ --include="*.sol"
```

### 驗證步驟
1. 比較 typeHash string 和實際 struct 欄位（名稱、順序、類型）
2. 確認巢狀 struct 有遞迴 hash
3. 確認 dynamic types (string/bytes/array) 用 keccak256
4. 確認 abi.encode（非 encodePacked）用於 struct hash

## 審計 Checklist

- [ ] TypeHash string 和 struct 定義完全一致？
- [ ] 巢狀 struct 是否遞迴 hash？
- [ ] Dynamic types 是否先 keccak256？
- [ ] 使用 abi.encode 而非 abi.encodePacked？
- [ ] 前端和合約產生的 hash 是否一致？（可用 cast 驗證）

## 真實案例

| 專案 | 問題 | 嚴重度 |
|------|------|--------|
| Seaport early | TypeHash 與 struct 順序不匹配 | High |
| Multiple DEXes | encodePacked hash collision | Medium |
| NFT Marketplaces | 巢狀 struct 未遞迴 hash | High |

## 標籤
`signature` `eip712` `typehash` `hash-collision` `medium-severity` `high-severity`
