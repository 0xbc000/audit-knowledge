# Signature Replay Attack

## 風險等級
**High ~ Critical** — 可導致未授權操作重複執行、資金被盜

## 描述

簽名重放攻擊發生在：已使用過的有效簽名可以被再次提交執行相同操作。常見三種變體：

1. **同鏈重放** — 同一合約上重複使用簽名（缺 nonce）
2. **跨鏈重放** — 簽名在不同鏈的同一合約上有效（domain separator 缺 chainId）
3. **跨合約重放** — 簽名在不同合約上有效（domain separator 缺 verifyingContract）

## 漏洞模式

### 模式 1: 缺少 Nonce（同鏈重放）

```solidity
// ❌ VULNERABLE — 無 nonce，簽名可無限重放
contract VulnerableAirdrop {
    function claim(uint256 amount, bytes memory signature) external {
        bytes32 hash = keccak256(abi.encodePacked(msg.sender, amount));
        address signer = ECDSA.recover(hash, signature);
        require(signer == admin, "Invalid signature");
        
        // 沒有記錄簽名已使用！
        token.transfer(msg.sender, amount);
    }
}
```

```solidity
// ✅ FIXED — nonce 防重放
contract FixedAirdrop {
    mapping(bytes32 => bool) public usedSignatures;
    
    function claim(uint256 amount, bytes memory signature) external {
        bytes32 hash = keccak256(abi.encodePacked(msg.sender, amount));
        require(!usedSignatures[hash], "Already claimed");
        
        address signer = ECDSA.recover(hash, signature);
        require(signer == admin, "Invalid signature");
        
        usedSignatures[hash] = true;
        token.transfer(msg.sender, amount);
    }
}
```

### 模式 2: Domain Separator 缺 chainId（跨鏈重放）

```solidity
// ❌ VULNERABLE
bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
    keccak256("EIP712Domain(string name,string version)"),
    keccak256("MyProtocol"),
    keccak256("1")
    // 缺少 chainId 和 verifyingContract！
));
```

```solidity
// ✅ FIXED — 完整 EIP-712 domain
bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
    keccak256("MyProtocol"),
    keccak256("1"),
    block.chainid,
    address(this)
));
```

### 模式 3: 硬編碼 Domain Separator（fork 後失效）

```solidity
// ❌ VULNERABLE — constructor 中計算，fork 後 chainId 改變但 separator 不變
constructor() {
    DOMAIN_SEPARATOR = _computeDomainSeparator(); // 被快取
}

// ✅ FIXED — 動態計算或 fork 檢測
function domainSeparator() public view returns (bytes32) {
    if (block.chainid == INITIAL_CHAIN_ID) {
        return INITIAL_DOMAIN_SEPARATOR;
    }
    return _computeDomainSeparator();
}
```

## 真實案例

### Wintermute / Optimism (2022)
- 20M OP tokens 的 multisig 部署簽名在 Optimism 上被重放
- 根因：Gnosis Safe 部署交易未綁定 chainId
- 損失：20M OP（後歸還大部分）

### Poly Network (2021)
- 跨鏈簽名驗證缺陷
- 損失：$611M（後歸還）

### Sushi RouteProcessor3 (2023)
- approve 簽名可被重放 drain 已授權用戶
- 損失：$3.3M

## 檢測方法

### 靜態掃描
```bash
# 找所有 ecrecover / ECDSA.recover 調用
grep -rn "ecrecover\|ECDSA.recover\|SignatureChecker" contracts/ --include="*.sol"

# 檢查是否有 nonce 管理
grep -rn "nonce\|usedSignatures\|usedHashes" contracts/ --include="*.sol"

# 檢查 domain separator 組成
grep -rn "EIP712Domain\|DOMAIN_SEPARATOR\|domainSeparator" contracts/ --include="*.sol"
```

### 審計問題清單
1. 簽名 hash 是否包含所有必要參數？（who, what, when, where）
2. 使用過的簽名是否被標記為已消費？
3. Domain separator 是否包含 chainId + verifyingContract？
4. chainId 是否動態計算（防 fork）？
5. 簽名是否有 deadline/expiry？

## Foundry 測試模板

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/VulnerableAirdrop.sol";

contract ReplayTest is Test {
    VulnerableAirdrop airdrop;
    uint256 adminKey = 0xA11CE;
    address admin = vm.addr(adminKey);
    
    function setUp() public {
        airdrop = new VulnerableAirdrop(admin);
    }
    
    function test_signatureReplay() public {
        address user = address(0xBEEF);
        uint256 amount = 100e18;
        
        // Admin signs a claim for user
        bytes32 hash = keccak256(abi.encodePacked(user, amount));
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(adminKey, hash);
        bytes memory sig = abi.encodePacked(r, s, v);
        
        // First claim succeeds
        vm.prank(user);
        airdrop.claim(amount, sig);
        
        // ❌ Replay: same signature works again!
        vm.prank(user);
        airdrop.claim(amount, sig); // Should revert but doesn't
        
        // User got 2x tokens
        assertEq(token.balanceOf(user), 200e18);
    }
}
```

## 修復模式總結

| 攻擊面 | 防禦 |
|---------|------|
| 同鏈重放 | nonce 或 usedSignatures mapping |
| 跨鏈重放 | EIP-712 domain 含 chainId |
| 跨合約重放 | EIP-712 domain 含 verifyingContract |
| Fork 重放 | 動態計算 domain separator |
| 時間窗口 | deadline 參數 + 檢查 |

## 相關模式
- [ecrecover-pitfalls.md](ecrecover-pitfalls.md) — ecrecover 返回零地址
- [eip712-mistakes.md](eip712-mistakes.md) — EIP-712 實作錯誤
- [permit-bypass.md](permit-bypass.md) — ERC20 Permit 漏洞
- [../cross-chain/](../cross-chain/) — 跨鏈安全模式

## 標籤
`signature` `replay` `nonce` `eip712` `chainid` `high-severity` `critical`
