# 重複定義的常數 (Duplicate Constant Definitions)

## 風險等級
**Low** - 維護風險，可能導致不一致

## 描述
相同的常數在多個合約中重複定義，而非使用共用的常數庫。這增加了維護複雜度，當修改時可能遺漏某些地方。

## 漏洞模式

```solidity
// ❌ RAAC - veRAACToken.sol
uint256 public constant MAX_BOOST = 25000;  // 2.5x
uint256 public constant MIN_BOOST = 10000;  // 1x

// ❌ RAAC - BoostController.sol (重複！)
uint256 public constant MAX_BOOST = 25000;
uint256 public constant MIN_BOOST = 10000;

// ❌ RAAC - GaugeController.sol (又重複！)
uint256 public constant MAX_BOOST = 25000;
uint256 public constant MIN_BOOST = 10000;
```

## 風險場景

### 1. 修改遺漏
```solidity
// 假設團隊決定把 MAX_BOOST 改成 30000 (3x)
// 他們只改了 veRAACToken.sol

// veRAACToken.sol
uint256 public constant MAX_BOOST = 30000;  // ✅ 已更新

// BoostController.sol  
uint256 public constant MAX_BOOST = 25000;  // ❌ 忘了改！

// 結果：不同合約使用不同的上限，導致邏輯不一致
```

### 2. 跨合約驗證失效
```solidity
// GaugeController 計算 boost 時用 25000
function calculateBoost() returns (uint256) {
    if (boost > MAX_BOOST) boost = MAX_BOOST;  // 25000
    return boost;
}

// veRAACToken 驗證時用 30000  
function validateBoost(uint256 boost) view {
    require(boost <= MAX_BOOST);  // 30000
}

// 結果：GaugeController 永遠不會返回超過 25000，
//      但 veRAACToken 允許到 30000
```

## 檢測方法

### 1. 搜尋重複定義
```bash
# 找所有常數定義
grep -rn "constant.*=" contracts/ | grep -v "test" | sort

# 找相同名稱的常數
grep -rhn "uint256.*constant" contracts/*.sol | \
  awk -F'constant' '{print $2}' | sort | uniq -d
```

### 2. 自動化腳本
```python
import re
from collections import defaultdict

def find_duplicate_constants(contracts_dir):
    constants = defaultdict(list)
    pattern = r'(\w+)\s+public\s+constant\s+(\w+)\s*='
    
    for file in glob.glob(f"{contracts_dir}/**/*.sol"):
        with open(file) as f:
            for match in re.finditer(pattern, f.read()):
                name = match.group(2)
                constants[name].append(file)
    
    return {k: v for k, v in constants.items() if len(v) > 1}
```

### 3. Solhint 規則
```json
{
  "rules": {
    "no-duplicate-constant": "warn"
  }
}
```

## 正確做法

### 使用共用常數庫
```solidity
// ✅ libraries/Constants.sol
library BoostConstants {
    uint256 public constant MAX_BOOST = 25000;
    uint256 public constant MIN_BOOST = 10000;
}

library TimeConstants {
    uint256 public constant MIN_LOCK_DURATION = 365 days;
    uint256 public constant MAX_LOCK_DURATION = 1460 days;
}

// ✅ 在其他合約中引用
import {BoostConstants} from "../libraries/Constants.sol";

contract BoostController {
    function calculateBoost() returns (uint256) {
        if (boost > BoostConstants.MAX_BOOST) {
            boost = BoostConstants.MAX_BOOST;
        }
    }
}
```

### 使用介面常數
```solidity
// ✅ interfaces/IBoostConfig.sol
interface IBoostConfig {
    uint256 constant MAX_BOOST = 25000;
    uint256 constant MIN_BOOST = 10000;
}

// ✅ 合約繼承介面
contract BoostController is IBoostConfig {
    // MAX_BOOST 和 MIN_BOOST 自動可用
}
```

## AI 程式碼特徵

重複常數定義是 AI 生成程式碼的典型特徵：
1. AI 傾向在每個需要的地方獨立定義
2. AI 不會主動抽取共用邏輯
3. AI 可能從不同來源複製相似的程式碼

**審計 AI 程式碼時應特別注意常數一致性！**

## 真實案例

| 專案 | 常數 | 重複次數 | 影響 |
|------|------|---------|------|
| RAAC 2025 | MAX_BOOST/MIN_BOOST | 3 | Low |
| RAAC 2025 | VOTE_DELAY | 2 | Low |

## 相關模式
- [magic-numbers.md](../business-logic/magic-numbers.md) (待新增)
- [commented-out-logic.md](./commented-out-logic.md)
