# Flash Loan Vulnerability Patterns

## Overview

Flash loans enable borrowing large amounts without collateral, repaid in same transaction.
Attack vector: manipulate state within single transaction.

---

## Pattern 1: Price Oracle Manipulation

### Description
Attacker uses flash loan to manipulate spot prices that oracles read.

### Vulnerable Code
```solidity
function getPrice() public view returns (uint256) {
    // Reads current spot price - manipulable!
    return uniswapPair.getReserves().price();
}

function liquidate(address user) external {
    uint256 price = getPrice();  // Manipulated price
    require(isUnderwater(user, price), "Not liquidatable");
    // ... liquidate at manipulated price
}
```

### Attack Flow
```
1. Flash loan large amount of token A
2. Swap A → B on Uniswap, crashes A price
3. Call liquidate() using crashed price
4. Buy back A cheap, repay flash loan
5. Profit from liquidation bonus
```

### Detection
- [ ] Protocol uses spot prices from AMM?
- [ ] Price can affect liquidations/borrows/swaps?
- [ ] No TWAP or oracle aggregation?

### Fix
```solidity
// Use Chainlink or TWAP
function getPrice() public view returns (uint256) {
    return chainlinkOracle.latestAnswer();
    // Or: uniswapV3Pool.observe() for TWAP
}
```

---

## Pattern 2: Governance Flash Loan Attack

### Description
Flash loan tokens to gain voting power, pass malicious proposal.

### Vulnerable Code
```solidity
function propose(bytes calldata action) external {
    require(token.balanceOf(msg.sender) >= proposalThreshold);
    // ... create proposal
}

function vote(uint256 proposalId) external {
    uint256 votes = token.balanceOf(msg.sender);  // Current balance!
    proposals[proposalId].votes += votes;
}
```

### Attack Flow
```
1. Flash loan governance tokens
2. Create proposal or vote
3. Return tokens
4. Proposal passes with borrowed votes
```

### Detection
- [ ] Voting power = current token balance?
- [ ] No snapshot mechanism?
- [ ] Proposal creation uses current balance?

### Fix
```solidity
// Snapshot voting power at proposal creation
function vote(uint256 proposalId) external {
    uint256 snapshotBlock = proposals[proposalId].snapshotBlock;
    uint256 votes = token.getPastVotes(msg.sender, snapshotBlock);
    proposals[proposalId].votes += votes;
}
```

---

## Pattern 3: Reentrancy via Flash Loan Callback

### Description
Flash loan providers call borrower's callback - potential reentrancy vector.

### Vulnerable Code
```solidity
function flashLoan(uint256 amount) external {
    uint256 balanceBefore = token.balanceOf(address(this));
    
    token.transfer(msg.sender, amount);
    
    // Callback to borrower - they can reenter!
    IFlashBorrower(msg.sender).onFlashLoan(amount);
    
    // Check repayment
    require(token.balanceOf(address(this)) >= balanceBefore + fee);
}
```

### Detection
- [ ] External call before state finalization?
- [ ] Callback to untrusted address?
- [ ] No reentrancy guard?

### Fix
```solidity
function flashLoan(uint256 amount) external nonReentrant {
    // ... same logic but protected
}
```

---

## Pattern 4: Collateral Factor Manipulation

### Description
Flash loan to inflate collateral value, borrow against it.

### Vulnerable Code
```solidity
function deposit(uint256 amount) external {
    // Deposit LP tokens as collateral
    lpToken.transferFrom(msg.sender, address(this), amount);
    collateral[msg.sender] += getCollateralValue(amount);  // Spot price!
}

function borrow(uint256 amount) external {
    require(collateral[msg.sender] >= amount * 150 / 100);
    // ... issue loan
}
```

### Attack Flow
```
1. Flash loan ETH
2. Add liquidity to LP, inflate LP token price
3. Deposit LP as collateral (at inflated value)
4. Borrow max against inflated collateral
5. Remove liquidity, repay flash loan
6. Protocol left with bad debt
```

### Detection
- [ ] LP tokens accepted as collateral?
- [ ] Collateral value from spot reserves?
- [ ] Can deposit and borrow in same transaction?

### Fix
- Use fair LP pricing (Uniswap V2: `sqrt(reserve0 * reserve1)`)
- Time-weighted collateral values
- Borrowing delay after deposit

---

## Pattern 5: Empty Pool Attack (ERC4626)

### Description
Flash loan to manipulate share/asset ratio in vaults.

### Vulnerable Code
```solidity
// Standard ERC4626 with no protection
function deposit(uint256 assets) external returns (uint256 shares) {
    shares = totalSupply() == 0 
        ? assets 
        : assets * totalSupply() / totalAssets();
    _mint(msg.sender, shares);
    asset.transferFrom(msg.sender, address(this), assets);
}
```

### Attack Flow (First Depositor)
```
1. Deposit 1 wei, get 1 share
2. Flash loan huge amount, donate to vault
3. totalAssets now huge, totalSupply = 1
4. Victim deposits X, gets 0 shares (rounded down)
5. Withdraw, get victim's funds
```

### Detection
- [ ] ERC4626 with no virtual shares?
- [ ] First deposit unprotected?
- [ ] Donation to vault possible?

### Fix
```solidity
function _decimalsOffset() internal pure override returns (uint8) {
    return 3;  // Virtual shares offset
}

// Or: require minimum first deposit
// Or: dead shares on initialization
```

---

## Quick Reference

| Attack Type | Key Indicator | Mitigation |
|-------------|---------------|------------|
| Price Manipulation | Spot price oracle | TWAP, Chainlink |
| Governance | Current balance voting | Snapshots |
| Reentrancy | Callback before checks | nonReentrant |
| Collateral Inflate | LP as collateral + spot price | Fair pricing |
| ERC4626 Inflation | No virtual shares | decimalsOffset |

## Minimal Reproduction (Pattern 1: Price Oracle Manipulation)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract SimpleAMM {
    uint256 public reserveA = 100e18;
    uint256 public reserveB = 100e18;

    function swap(uint256 amtA) external {
        uint256 out = (amtA * reserveB) / (reserveA + amtA);
        reserveA += amtA;
        reserveB -= out;
    }

    function spotPrice() external view returns (uint256) {
        return (reserveB * 1e18) / reserveA;
    }
}

contract VulnerableLending {
    SimpleAMM public amm;
    mapping(address => uint256) public collateral;
    mapping(address => uint256) public debt;

    constructor(SimpleAMM _amm) { amm = _amm; }

    function deposit() external payable { collateral[msg.sender] += msg.value; }

    function borrow(uint256 amt) external {
        uint256 price = amm.spotPrice(); // ❌ uses spot price
        require(collateral[msg.sender] * price / 1e18 >= amt * 15 / 10);
        debt[msg.sender] += amt;
    }
}
```

### Foundry Test Draft

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";

// paste SimpleAMM and VulnerableLending above

contract FlashLoanOracleTest is Test {
    SimpleAMM amm;
    VulnerableLending lending;

    function setUp() public {
        amm = new SimpleAMM();
        lending = new VulnerableLending(amm);
    }

    function testSpotPriceManipulation() public {
        uint256 priceBefore = amm.spotPrice();
        // Simulate flash loan: massive swap crashes price
        amm.swap(900e18);
        uint256 priceAfter = amm.spotPrice();
        assertLt(priceAfter, priceBefore / 5, "price should crash >80%");
    }
}
```

---

## Related Patterns
- `oracle/` - Price manipulation details
- `reentrancy/` - Callback patterns
- `erc4626/` - Vault-specific attacks
