# Governance Vulnerability Patterns

## Overview

Governance systems control protocol parameters, upgrades, and treasury.
Attacks can lead to total protocol takeover.

---

## Pattern 1: Flash Loan Governance Attack

### Description
Borrow tokens to gain temporary voting power.

### Vulnerable Code
```solidity
function getVotes(address account) public view returns (uint256) {
    // Current balance = voting power
    return token.balanceOf(account);
}

function castVote(uint256 proposalId, bool support) external {
    uint256 votes = getVotes(msg.sender);
    proposals[proposalId].votes[support] += votes;
}
```

### Attack
```
1. Flash loan 51% of governance tokens
2. Vote on malicious proposal
3. Return tokens in same tx
4. Proposal passes
```

### Detection
- [ ] Voting power = current balance?
- [ ] No snapshot at proposal creation?
- [ ] Token is flash-loanable?

### Fix
```solidity
// Use checkpoint-based voting
function castVote(uint256 proposalId, bool support) external {
    uint256 snapshotId = proposals[proposalId].snapshotId;
    uint256 votes = token.getPastVotes(msg.sender, snapshotId);
    
    require(!hasVoted[proposalId][msg.sender], "Already voted");
    hasVoted[proposalId][msg.sender] = true;
    
    proposals[proposalId].votes[support] += votes;
}
```

---

## Pattern 2: Proposal Spam / Griefing

### Description
Attacker creates many proposals to confuse voters or exhaust gas.

### Vulnerable Code
```solidity
function propose(bytes calldata action) external returns (uint256) {
    require(token.balanceOf(msg.sender) >= proposalThreshold);
    
    // No limit on active proposals!
    uint256 proposalId = nextProposalId++;
    proposals[proposalId] = Proposal({
        action: action,
        proposer: msg.sender,
        // ...
    });
    return proposalId;
}
```

### Attack
```
1. Acquire threshold tokens (or flash loan)
2. Create 1000 proposals
3. Legitimate proposals buried
4. Voter fatigue / confusion
```

### Detection
- [ ] Limit on active proposals per address?
- [ ] Proposal deposit required?
- [ ] Cooldown between proposals?

### Fix
```solidity
mapping(address => uint256) public activeProposals;
uint256 public constant MAX_ACTIVE_PROPOSALS = 3;
uint256 public constant PROPOSAL_DEPOSIT = 100 ether;

function propose(bytes calldata action) external returns (uint256) {
    require(activeProposals[msg.sender] < MAX_ACTIVE_PROPOSALS);
    
    // Require deposit (returned if proposal passes)
    token.transferFrom(msg.sender, address(this), PROPOSAL_DEPOSIT);
    
    activeProposals[msg.sender]++;
    // ... create proposal
}
```

---

## Pattern 3: Timelock Bypass

### Description
Circumventing timelock protections for instant execution.

### Vulnerable Code
```solidity
contract Timelock {
    function queueTransaction(bytes32 txHash) external onlyGovernance {
        queuedAt[txHash] = block.timestamp;
    }
    
    function executeTransaction(bytes32 txHash) external {
        require(block.timestamp >= queuedAt[txHash] + delay);
        // Execute...
    }
    
    // DANGEROUS: Emergency function with no delay
    function emergencyExecute(bytes calldata data) external onlyAdmin {
        (bool success,) = target.call(data);
        require(success);
    }
}
```

### Attack
```
1. Compromise admin key or governance
2. Use emergencyExecute to bypass timelock
3. Instantly drain treasury or upgrade maliciously
```

### Detection
- [ ] Emergency functions exist?
- [ ] What can bypass timelock?
- [ ] Emergency requires multisig?

### Fix
```solidity
// Emergency still requires delay (shorter)
uint256 public constant EMERGENCY_DELAY = 6 hours;
uint256 public constant NORMAL_DELAY = 2 days;

function emergencyExecute(bytes32 txHash) external onlyMultisig {
    require(
        block.timestamp >= queuedAt[txHash] + EMERGENCY_DELAY,
        "Emergency delay not passed"
    );
    // ...
}
```

---

## Pattern 4: Quorum Manipulation

### Description
Manipulating participation to meet or avoid quorum.

### Vulnerable Code
```solidity
function execute(uint256 proposalId) external {
    Proposal storage p = proposals[proposalId];
    
    // Quorum based on current total supply
    uint256 quorum = token.totalSupply() * 4 / 100;  // 4%
    
    require(p.forVotes + p.againstVotes >= quorum, "Quorum not reached");
    require(p.forVotes > p.againstVotes, "Not passed");
    // Execute...
}
```

### Attack (Token Burn)
```
1. Create malicious proposal
2. Burn tokens to reduce totalSupply
3. Lower quorum threshold
4. Proposal passes with fewer votes
```

### Detection
- [ ] Quorum uses current supply?
- [ ] Token can be burned?
- [ ] Quorum snapshot at proposal creation?

### Fix
```solidity
function propose(...) external {
    proposals[nextId] = Proposal({
        // Snapshot quorum at creation time
        quorumSnapshot: token.totalSupply() * 4 / 100,
        snapshotBlock: block.number,
        // ...
    });
}

function execute(uint256 proposalId) external {
    Proposal storage p = proposals[proposalId];
    require(p.forVotes + p.againstVotes >= p.quorumSnapshot);
    // ...
}
```

---

## Pattern 5: Vote Buying / Dark DAOs

### Description
Off-chain vote buying through smart contracts.

### Vulnerable Pattern
```solidity
// Anyone can see how addresses voted
mapping(address => mapping(uint256 => bool)) public votes;

function castVote(uint256 proposalId, bool support) external {
    votes[msg.sender][proposalId] = support;
    // ... record vote
}
```

### Attack (Vote Buying Contract)
```solidity
contract VoteBuyer {
    function buyVote(uint256 proposalId) external {
        // Verify voter voted "yes" on main governance
        require(governance.votes(msg.sender, proposalId) == true);
        // Pay voter
        token.transfer(msg.sender, BRIBE_AMOUNT);
    }
}
```

### Detection
- [ ] Votes publicly readable?
- [ ] Can verify vote on-chain?
- [ ] High-value proposals?

### Mitigations
- Commit-reveal voting (hides vote until reveal)
- MACI (Minimum Anti-Collusion Infrastructure)
- Conviction voting (time-weighted)

---

## Pattern 6: Delegate Griefing

### Description
Abusing delegation mechanics to grief voters.

### Vulnerable Code
```solidity
function delegate(address delegatee) external {
    // No limit on delegation changes
    _delegates[msg.sender] = delegatee;
    // Move voting power
    _moveVotingPower(msg.sender, delegatee, balanceOf(msg.sender));
}
```

### Attack
```
1. Delegate to victim
2. Victim now has more votes than expected
3. Re-delegate away just before snapshot
4. Victim's expected voting power disappears
```

### Detection
- [ ] Delegation changes instantly effective?
- [ ] Can delegate/undelegate rapidly?
- [ ] Delegation affects active proposals?

### Fix
```solidity
// Delegation changes take effect next block
function delegate(address delegatee) external {
    pendingDelegation[msg.sender] = PendingDelegation({
        delegatee: delegatee,
        effectiveBlock: block.number + 1
    });
}
```

---

## Pattern 7: Governance Takeover via Token Inflation

### Description
Mint new tokens to gain majority voting power.

### Vulnerable Code
```solidity
// Governance can mint tokens
function execute(bytes calldata data) external onlyGovernance {
    (bool success,) = token.call(data);
    require(success);
}

// Token has mint function callable by governance
function mint(address to, uint256 amount) external onlyGovernance {
    _mint(to, amount);
}
```

### Attack
```
1. Gain 51% control (or compromise governance)
2. Propose to mint 10x supply to attacker
3. Now attacker has 90%+ control permanently
```

### Detection
- [ ] Governance can mint tokens?
- [ ] Token supply capped?
- [ ] Mint has rate limit?

### Fix
- Hard cap on token supply
- Mint rate limits in token contract
- Separate minting authority from governance

---

## Quick Reference

| Attack Type | Key Indicator | Mitigation |
|-------------|---------------|------------|
| Flash Loan Vote | Current balance voting | Checkpoint snapshots |
| Proposal Spam | No limits | Deposit + cooldown |
| Timelock Bypass | Emergency function | Multi-delay + multisig |
| Quorum Manipulation | Current supply quorum | Snapshot at creation |
| Vote Buying | Public vote record | Commit-reveal / MACI |
| Delegate Grief | Instant delegation | Delayed effectiveness |
| Token Inflation | Gov can mint | Hard cap + rate limit |

## Governance Security Checklist

- [ ] Voting power uses snapshots (not current balance)
- [ ] Proposal threshold prevents spam
- [ ] Quorum is snapshot-based
- [ ] Timelock for all sensitive operations
- [ ] Emergency functions are protected
- [ ] Delegation has sane limits
- [ ] Token supply has hard cap
- [ ] Upgrade path is timelocked

## Related Patterns
- `flash-loan/` - Flash loan voting details
- `access-control/` - Admin/governance permissions
- `upgrade/` - Governance-controlled upgrades
