# Arithmetic Findings (Solodit)

> Mathematical and arithmetic vulnerabilities

## Overview

| ID | Severity | Title | Platform |
|----|----------|-------|----------|
| SOL-011 | 游리 medium | Division Before Multiplication Precision Loss | Code4rena |
| SOL-012 | 游 high | Unsafe Downcast from uint256 to uint128 | Sherlock |
| SOL-031 | 游 high | Rounding Favors Attacker in Withdrawal | Sherlock |
| SOL-032 | 游리 medium | Interest Accrual Skipped for Small Amounts | Code4rena |
| SOL-033 | 游댮 critical | Unchecked uint256 to int256 Cast | Sherlock |
| SOL-050 | 游 high | Compound Interest Calculation Error | Code4rena |
| SOL-052 | 游 high | Interest Rate Model Overflow at High Utilization | Code4rena |
| SOL-054 | 游 high | Reward Distribution to Zero Stakers | Code4rena |
| SOL-058 | 游댮 critical | Concentrated Liquidity Position Theft | Immunefi |
| SOL-061 | 游 high | Funding Rate Calculation Rounds to Zero | Code4rena |
| SOL-066 | 游댮 critical | ERC4626 Share Inflation via Donation | Sherlock |

---

## SOL-011: Division Before Multiplication Precision Loss

**Severity:** 游리 MEDIUM  
**Platform:** Code4rena  
**Protocol Type:** DeFi Protocol

### Description
Fee calculation performs division before multiplication, causing precision loss that favors one party.

### Impact
Users pay less fees than intended, or receive incorrect rewards.

### Vulnerable Code
```solidity
uint256 fee = amount / 1000 * feeRate;  // Precision loss!
```

### Fix
```solidity
uint256 fee = amount * feeRate / 1000;  // Multiply first
```

---

## SOL-012: Unsafe Downcast from uint256 to uint128

**Severity:** 游 HIGH  
**Platform:** Sherlock  
**Protocol Type:** DeFi Protocol

### Description
Casting large uint256 to uint128 without bounds check causes silent overflow.

### Impact
Large values wrap around, causing incorrect calculations.

### Vulnerable Code
```solidity
uint128 truncated = uint128(largeValue);  // Silent overflow if > 2^128
```

### Fix
```solidity
require(largeValue <= type(uint128).max, "Overflow");
uint128 truncated = uint128(largeValue);
```

---

## SOL-031: Rounding Favors Attacker in Withdrawal

**Severity:** 游 HIGH  
**Platform:** Sherlock  
**Protocol Type:** Vault Protocol

### Description
Withdrawal rounds up shares burned but rounds down assets returned.

### Impact
Attacker extracts extra value via many small withdrawals.

### Vulnerable Code
```solidity
function withdraw(uint256 assets) external returns (uint256 shares) {
    shares = assets.mulDiv(totalSupply, totalAssets, Math.Rounding.Up);  // Up
    assets = shares.mulDiv(totalAssets, totalSupply, Math.Rounding.Down);  // Down
}
```

### Fix
```solidity
// Round in protocol's favor
shares = assets.mulDiv(totalSupply, totalAssets, Math.Rounding.Up);
assets = shares.mulDiv(totalAssets, totalSupply, Math.Rounding.Up);
```

---

## SOL-032: Interest Accrual Skipped for Small Amounts

**Severity:** 游리 MEDIUM  
**Platform:** Code4rena  
**Protocol Type:** Lending Protocol

### Description
Integer division causes 0 interest for small debt amounts over short periods.

### Impact
Small borrowers pay no interest, subsidized by large borrowers.

### Vulnerable Code
```solidity
uint256 interest = principal * rate * time / 1e18 / SECONDS_PER_YEAR;
// If principal * rate * time < 1e18 * YEAR, interest = 0
```

### Fix
```solidity
// Use higher precision internally
// Or minimum interest amount
```

---

## SOL-033: Unchecked uint256 to int256 Cast

**Severity:** 游댮 CRITICAL  
**Platform:** Sherlock  
**Protocol Type:** Perp DEX

### Description
Large positive uint256 becomes negative when cast to int256.

### Impact
Position values become negative, enabling exploitation.

### Vulnerable Code
```solidity
int256 pnl = int256(positionValue - initialValue);
// If positionValue > type(int256).max, pnl is negative!
```

### Fix
```solidity
require(positionValue <= uint256(type(int256).max), "Overflow");
int256 pnl = int256(positionValue) - int256(initialValue);
```

---

## SOL-050: Compound Interest Calculation Error

**Severity:** 游 HIGH  
**Platform:** Code4rena  
**Protocol Type:** Lending Protocol

### Description
Simple interest formula used instead of compound, diverges over time.

### Impact
Borrowers pay less interest than expected, protocol loses.

### Vulnerable Code
```solidity
// Simple interest
uint256 interest = principal * rate * time / SECONDS_PER_YEAR;
```

### Fix
```solidity
// Compound interest with per-block accrual
uint256 ratePerBlock = rate / BLOCKS_PER_YEAR;
uint256 factor = (1 + ratePerBlock) ** blocks;
uint256 amount = principal * factor;
```

---

## SOL-052: Interest Rate Model Overflow at High Utilization

**Severity:** 游 HIGH  
**Platform:** Code4rena  
**Protocol Type:** Lending Protocol

### Description
Interest rate calculation overflows when utilization approaches 100%.

### Impact
Interest rate becomes 0 or negative at critical times.

### Vulnerable Code
```solidity
uint256 rate = baseRate + (utilization * multiplier / (1e18 - utilization));
// Overflow when utilization approaches 1e18
```

### Fix
```solidity
require(utilization < MAX_UTILIZATION, "Utilization too high");
```

---

## SOL-054: Reward Distribution to Zero Stakers

**Severity:** 游 HIGH  
**Platform:** Code4rena  
**Protocol Type:** Staking Protocol

### Description
Rewards added when totalStaked = 0 are permanently lost.

### Impact
Protocol tokens stuck in contract forever.

### Vulnerable Code
```solidity
function notifyReward(uint256 amount) external {
    rewardPerToken += amount * 1e18 / totalStaked;  // Division by zero!
}
```

### Fix
```solidity
require(totalStaked > 0, "No stakers");
```

---

## SOL-058: Concentrated Liquidity Position Theft

**Severity:** 游댮 CRITICAL  
**Platform:** Immunefi  
**Protocol Type:** AMM Protocol

### Description
Rounding error allows extracting more liquidity than deposited.

### Impact
Attacker drains pool via repeated add/remove.

### Vulnerable Code
```solidity
// Small positions round in attacker's favor
// 1000 iterations extracts significant value
```

### Fix
```solidity
// Round against user in both add and remove
```

---

## SOL-061: Funding Rate Calculation Rounds to Zero

**Severity:** 游 HIGH  
**Platform:** Code4rena  
**Protocol Type:** Perp DEX

### Description
Small funding rate * small position = 0 due to rounding.

### Impact
Small positions never pay funding, imbalance accumulates.

### Vulnerable Code
```solidity
uint256 funding = position * rate / 1e18;  // Rounds to 0 for small
```

### Fix
```solidity
// Accumulate funding internally before applying
```

---

## SOL-066: ERC4626 Share Inflation via Donation

**Severity:** 游댮 CRITICAL  
**Platform:** Sherlock  
**Protocol Type:** Vault Protocol

### Description
First depositor donates to inflate share price, subsequent depositors get 0 shares.

### Impact
Up to 100% theft of subsequent deposits.

### Vulnerable Code
```solidity
// Attacker: deposit 1 wei, donate 1e18 tokens
// Victim deposits 0.5e18, gets 0 shares
```

### Fix
```solidity
// Virtual shares offset
function _convertToShares(uint256 assets) internal view returns (uint256) {
    return assets.mulDiv(totalSupply() + 1e3, totalAssets() + 1);
}
```

---


*Imported from Solodit curated findings*
