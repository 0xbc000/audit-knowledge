# Olas Protocol - V12 AI Audit Findings Analysis

## Protocol Overview

**Type:** DAO Infrastructure (Governance + Tokenomics + Registry)
**Chain:** Multi-chain (Ethereum, Arbitrum, Optimism, Gnosis, Polygon)
**Audit:** Code4rena Jan 2025, $62K prize pool
**AI Tool:** V12 by Zellic

## Key Findings Summary

### Critical (Governance)

#### [C-01] VerifyBridgedData Assembly 解析錯誤

**File:** `VerifyBridgedData._verifyBridgedData`

**問題：** 
```solidity
assembly {
    // ❌ 缺少 32-byte 長度前綴 offset
    i := add(i, 20)
    target := mload(add(data, i))
    // 讀取位置錯誤，驗證的數據和實際執行的不同
}
```

**Root Cause:**
1. `mload(add(data, i))` 沒加 `0x20` offset
2. 不一致的 offset 遞增（有時 +16，有時 +20）
3. 沒有 mask sub-word 類型
4. 缺少邊界檢查

**Impact:** 攻擊者可偽造跨鏈消息，繞過驗證

---

#### [C-02] BridgeMessenger Self-Call 繞過

**File:** `BridgeMessenger._processData`, `WormholeMessenger.changeSourceGovernor`

**問題：**
```solidity
// _processData 解析 target 並執行
(bool success,) = target.call{value: value}(payload);

// changeSourceGovernor 只檢查 msg.sender
function changeSourceGovernor(bytes32 newSourceGovernor) external {
    if (msg.sender != address(this)) {  // ← 可被繞過！
        revert SelfCallOnly(msg.sender, address(this));
    }
    sourceGovernor = newSourceGovernor;
}
```

**Attack Flow:**
1. 構造 bridged message: `target = BridgeMessenger address`
2. Payload = `abi.encodeCall(changeSourceGovernor, attackerAddress)`
3. 經過合法的 bridge 發送
4. `_processData` 執行 `this.call(payload)`
5. `msg.sender == address(this)` 通過
6. Governor 被改成攻擊者控制

---

### QA - Oracle TWAP (我也找到的)

#### Oracle/TWAP Integrity Failures

**File:** `UniswapPriceOracle.validatePrice`, `BalancerPriceOracle`

**問題：**
```solidity
uint256 cumulativePrice = cumulativePriceLast + (tradePrice * elapsedTime);
uint256 timeWeightedAverage = (cumulativePrice - cumulativePriceLast) / elapsedTime;
// 數學上: = tradePrice，TWAP 失效
```

**V12 描述：**
> "TWAP collapse to spot: algebraic/units errors or tautological computations make the TWAP equal the instantaneous manipulated price"

**Impact:** Flash loan 價格操縱，MEV 攻擊

---

### QA - Unprotected Initializers

**Affected:** `Tokenomics`, `LiquidityManagerCore`, `BuyBackBurner`, `ServiceManager`

**問題：**
```solidity
function initialize(bytes memory payload) external {
    if (owner != address(0)) {
        revert AlreadyInitialized();
    }
    owner = msg.sender;  // First caller wins
}
```

---

### QA - V3 Swap amountOutMinimum=1

**File:** `BuyBackBurnerUniswap._performSwap`

**問題：**
```solidity
ExactInputSingleParams({
    // ...
    amountOutMinimum: 1,  // ❌ 幾乎沒有滑點保護
    // ...
})
```

**Impact:** Sandwich 攻擊可提取幾乎所有價值

---

## Patterns Learned

### 1. Assembly 解析必查清單
- [ ] bytes 的 32-byte length prefix
- [ ] mload 需要 mask sub-word types
- [ ] offset 追蹤一致性
- [ ] bounds checking

### 2. Self-Call 繞過
當合約執行 `target.call(payload)` 且 target 可控時，檢查是否能調用自身的 protected 函數。

### 3. Proxy Initializer
任何 `initialize()` 函數如果只用 `owner == address(0)` 保護，都是風險。

### 4. Uniswap V3 滑點
`amountOutMinimum: 1` 是常見錯誤，應該基於 oracle 計算合理的最小輸出。

## Tags

`governance` `cross-chain` `bridge` `assembly` `oracle` `proxy` `initializer`
